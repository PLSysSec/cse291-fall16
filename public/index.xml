<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CSE 291</title>
    <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/</link>
    <description>Recent content on CSE 291</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</managingEditor>
    <webMaster>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</webMaster>
    <lastBuildDate>Tue, 29 Nov 2016 01:37:22 -0702</lastBuildDate>
    <atom:link href="https://cseweb.ucsd.edu/~dstefan/cse291-fall16/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>miTLS</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/mitls/</link>
      <pubDate>Tue, 29 Nov 2016 01:37:22 -0702</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/mitls/</guid>
      <description>

&lt;p&gt;Author: Atyansh Jaiswal&lt;/p&gt;

&lt;p&gt;##What is TLS?&lt;/p&gt;

&lt;p&gt;TLS stands for &amp;ldquo;Transport Layer Security&amp;rdquo; and is the most used protocol for
secure communication. It&amp;rsquo;s primarily used for communication over web in the
form of https. It&amp;rsquo;s a direct successor of Secure Sockets Layer (SSL) and is
quite frequently called as SSL (TLS 1.0 was released as SSL 3.1).&lt;/p&gt;

&lt;h2 id=&#34;what-does-tls-do&#34;&gt;What does TLS do?&lt;/h2&gt;

&lt;p&gt;In general, TLS comprises of a handshake protocol and a record protocol. The
handshake protocol allows a server and client to authenticate each other via
some form of asymmetric encryption, while allowing the securely create a shared
shared key. The record protocol provides connection security for communication
between the server and the client, usually with some form of authenticated
encryption scheme. TLS provides a variety of cryptographic suites to facilitate
these protocols. The cryptographic suites range in strength with some old but
insecure algorithms still being supported for compatibility purpose.&lt;/p&gt;

&lt;h2 id=&#34;what-s-the-paper-about&#34;&gt;What&amp;rsquo;s the paper about?&lt;/h2&gt;

&lt;p&gt;TLS has had a long history of security breaking bugs, usually to defects in the
implementation of the protocol. The miTLS paper presents a verified reference
implementation of TLS 1.2 written in F#. They create a modular implementation of
TLS and use PL abstractions (in particular refinement types and abstract types)
to prove soundness and security of their implementation of the protocol. They
also discuss some interesting attacks and how their implementation fixes them.&lt;/p&gt;

&lt;h2 id=&#34;what-are-the-main-goals-of-mitls&#34;&gt;What are the main goals of miTLS?&lt;/h2&gt;

&lt;p&gt;miTLS creates a reference implementation of TLS with the 2 main goals in mind-&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Standard Compliance - Their implementation is compatible with the current TLS
RFC and can be used with various systems that use TLS. As such, their protocol
supports some ciphersuites such as RC4, which is known to be weak, but they mark
these as weak in their type system.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Verified Security - The security of the protocol is provably secure, i.e. the
privacy and integrity of data sent over TLS is preserved provided that strong
cryptographic ciphersuites were used to establish the handshake and connection
keys. They do this by designing classic indistinguishability and integrity games
using their typed primitives.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;modular-implementation-of-mitls&#34;&gt;Modular Implementation of miTLS&lt;/h2&gt;

&lt;p&gt;The implementation of miTLS is split into 45 different modules. Each module is
specified with an interface and an implementation. The interface declares the
types and functions exported by the module. The F7 typechecker verifies the
modules using these interface (using Z3 as an SMT solver to solve the logical
proofs). The modules are grouped into several major components, each with a
specific function. Interesting ones to note are the Record layer, which handles
the record protocol, and the upper layer, which consists of the handshake
protocol, alerts, and application data.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a dispatch module that handles communication between these components
and the application, as such it handles message passing, fragmentation, etc.&lt;/p&gt;

&lt;h2 id=&#34;how-do-modules-help-provide-security&#34;&gt;How do modules help provide security?&lt;/h2&gt;

&lt;p&gt;Proving security properties of each module separately allows for compositional
reasoning of security. In particular, the authors say that their main
contribution in this paper is that they can verify record layer security with
their Stateful Authenticate Encryption Module (StAE), Handshake layer security
with their Handshake Module (HS), and that the TLS protocol logic that deals
with application data, alerts, etc. securely implements the main API given
secure implementations of StAE and HS.&lt;/p&gt;

&lt;h2 id=&#34;what-new-attacks-did-they-discover&#34;&gt;What new attacks did they discover?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The authors discuss an Alert Fragmentation attack where an attacker could
insert an alert fragment as part of the communication which is buffered, so
when the correct alert comes in, it&amp;rsquo;s seen as a continuation of the previous
alert fragment, which breaks alert authentication. They fixed this by verifying
that alert buffer is empty at the completion of a handshake.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Fingerprinting attack using compression - Not all ciphertexts provide security
against this. The amount that the plaintext can be compressed can reveal the
entropy of the plaintext which breaks the indistinguishability principle. They
fixed this by disabling TLS level compression in their implementation.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cryptographic-security-by-typing&#34;&gt;Cryptographic Security by Typing&lt;/h2&gt;

&lt;p&gt;The authors use F7, which is a refinement typechecker for F#. They take of two
abstractions in type theory to prove security properties-&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Refinements Types - These are types with predicates attached to them that can
be typechecked. As such, a type c:cert(Authorized(u,c)) specifies c to be of
type cert, such that c is an authorized cert for user u. This way, they can
encode the security properties of the primitives as part of the type system.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Abstract Types - Types can be declared as abstract which keeps the
representation of the type private, which ensures that any module will treat them
as opaque values, which provides secrecy and integrity.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;how-they-use-typing-rules&#34;&gt;How they use typing rules&lt;/h2&gt;

&lt;p&gt;The main property of their type system is that a well-typed expression is always
safe (Theorem 1).&lt;/p&gt;

&lt;p&gt;Theorem 2 provides the property that a program interacting with secrets kept
within 2 different modules cannot distinguish between the two.&lt;/p&gt;

&lt;p&gt;They then define cryptographic games in their type system and show that the
security properties can be proven by the types alone rather than the
implementation. They represent weak cryptographic suites with not(Strong), which
allows the type checker to represent their weakness. They also define LEAK and
COERCE to represent key compromise and provide security guarantees against them.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Micro-policies</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/micro-policies/</link>
      <pubDate>Tue, 29 Nov 2016 01:37:21 -0702</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/micro-policies/</guid>
      <description>

&lt;p&gt;Author: Hannah Chou&lt;/p&gt;

&lt;h4 id=&#34;what-are-the-high-level-contributions-of-this-paper&#34;&gt;What are the high-level contributions of this paper?&lt;/h4&gt;

&lt;p&gt;A methodology to formally verify security of various security reference
monitors atop tagged hardware.&lt;/p&gt;

&lt;h4 id=&#34;what-is-a-reference-monitor&#34;&gt;What is a reference monitor?&lt;/h4&gt;

&lt;p&gt;Code/hardware that mediates all operations according to a security policy. The
monitor should generally be small (easy to audit, since this is the TCB),
self-protecting and correct.&lt;/p&gt;

&lt;h4 id=&#34;what-are-downsides-to-implementing-a-reference-monitor-in-software&#34;&gt;What are downsides to implementing a reference monitor in software?&lt;/h4&gt;

&lt;p&gt;Performance and security.&lt;/p&gt;

&lt;h4 id=&#34;what-are-the-3-machine-classes-that-the-authors-present-as-part-of-their-methodology&#34;&gt;What are the 3 machine classes that the authors present as part of their methodology?&lt;/h4&gt;

&lt;p&gt;Abstract machine, symbolic machine, concrete machine.&lt;/p&gt;

&lt;h4 id=&#34;why-do-the-authors-split-it-up-into-3-parts-how-is-it-useful&#34;&gt;Why do the authors split it up into 3 parts? How is it useful?&lt;/h4&gt;

&lt;p&gt;The abstraction level helps with reasoning about security policies at a high
level irrespective of the implementation. The symbolic layer specifies the
micro-policies in terms of symbolic tags. FInally, the concrete is the
implementation that reflects the hardware. All layers are written in Coq,
allowing proofs of security policies.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-purpose-of-backward-refinement&#34;&gt;What is the purpose of backward refinement?&lt;/h4&gt;

&lt;p&gt;To prove that any program that is safe (and thus takes a step) in a low-level
machine can take a step in the high-level machine. When a program is about to
violate security, it gets stuck.&lt;/p&gt;

&lt;h4 id=&#34;why-can-t-don-t-they-use-forward-refinement&#34;&gt;Why can&amp;rsquo;t/don&amp;rsquo;t they use forward refinement?&lt;/h4&gt;

&lt;p&gt;Forward refinement would require that the abstract levels account for details
in the lower, more concrete level. That would defeat the purpose of having
abstract levels that hide details of implementation.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-abstract-machine&#34;&gt;What is the abstract machine?&lt;/h4&gt;

&lt;p&gt;The basic RISC machine with added instruction primitives and pre-conditions
specific to a security policy (e.g. mkkey, seal, and unseal for the Sealing
Machine example).&lt;/p&gt;

&lt;h4 id=&#34;what-is-a-monitor-service&#34;&gt;What is a monitor service?&lt;/h4&gt;

&lt;p&gt;A monitor service is the added instruction primitives that are implemented as a
rule in the symbolic machine.&lt;/p&gt;

&lt;h4 id=&#34;what-are-the-assumptions-they-make-with-the-monitor-services&#34;&gt;What are the assumptions they make with the monitor services?&lt;/h4&gt;

&lt;p&gt;That the service code is good and safe as provided by the micro-policy
designer. The encoding has to be correct to some degree, but their backwards
refinement proof also help ensure that a bad implementation can&amp;rsquo;t be proved
correct.&lt;/p&gt;

&lt;h4 id=&#34;why-do-they-use-a-rule-cache-in-the-concrete-machine&#34;&gt;Why do they use a rule cache in the concrete machine?&lt;/h4&gt;

&lt;p&gt;To improve performance.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-job-of-the-miss-handler&#34;&gt;What is the job of the miss-handler?&lt;/h4&gt;

&lt;p&gt;The miss handler retrieves rules if they are missed in the rule cache and
compares the rules to the attempted instruction. Because of this mixed hardware
software approach, they can&amp;rsquo;t actually address covert channel information
leakage attacks (that you may care about in an IFC system).&lt;/p&gt;

&lt;h4 id=&#34;what-are-the-four-types-of-tags&#34;&gt;What are the four types of tags?&lt;/h4&gt;

&lt;p&gt;Memory, registers, PC, and services.&lt;/p&gt;

&lt;h4 id=&#34;do-micro-policies-associate-with-memory-contents-or-with-memory-locations-would-this-matter-for-implementation-for-concrete-machines&#34;&gt;Do micro-policies associate with memory contents or with memory locations? Would this matter for implementation for concrete machines?&lt;/h4&gt;

&lt;p&gt;They could be associated with both. Yes, it just means it is implemented
differently in concrete machines, but it is the same syntax in the symbolic
machine.&lt;/p&gt;

&lt;h4 id=&#34;why-do-they-need-monitor-self-protection-how-do-they-implement-monitor-self-protection&#34;&gt;Why do they need monitor self-protection? How do they implement monitor self-protection?&lt;/h4&gt;

&lt;p&gt;The monitor code/data lives in ordinary memory. Monitor code/data is tagged
with a monitor tag so that untrusted code cannot access it. DS: Your memory
better have ECC, otherwise this is prone to the rowhammer.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SecVerilog questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/secverilog/</link>
      <pubDate>Tue, 22 Nov 2016 15:44:04 -0709</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/secverilog/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What is observational determinism? What is low-equivalence? Why do we care
about these?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Suppose you wanted to enforce IFC at run-time instead of statically. What
are 2 challenges with such an approach (e.g., in trying to implement a MIPS
processor)?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>SecVerilog</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/secverilog/</link>
      <pubDate>Tue, 22 Nov 2016 01:37:21 -0702</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/secverilog/</guid>
      <description>

&lt;p&gt;Author: Abdulrahman Alkhelaifi&lt;/p&gt;

&lt;h4 id=&#34;why-do-the-authors-want-to-implement-ifc-at-the-hardware-level&#34;&gt;Why do the authors want to implement IFC at the hardware level?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Hardware can be leveraged to create additional information flows that violate
a security policy such as timing channels if one only enforces this policy in
software.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IFC allows sharing resources as opposed to separating the hardware resources
into completely different levels/partitions which adds overhead and complexity.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-is-the-goal-of-secverilog&#34;&gt;What is the goal of SecVerilog?&lt;/h4&gt;

&lt;p&gt;Enforce fine-grained information flow control for hardware designs in a
statically verifiable fashion.&lt;/p&gt;

&lt;h4 id=&#34;how-does-secverilog-achieve-that-goal&#34;&gt;How does SecVerilog achieve that goal?&lt;/h4&gt;

&lt;p&gt;Variables (registers and wires) are labeled (e.g. low and high) such that the
labels specify a security lattice. The type system statically verifies that the
information flow does not violate the security policy defined by the labels.&lt;/p&gt;

&lt;h4 id=&#34;what-is-their-attacker-model-what-attacks-they-do-not-consider&#34;&gt;What is their attacker model? What attacks they do not consider?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The authors consider a software level adversary who can observe all public
information labeled low (storage channel) as well as measure the timing of
hardware operations (timing channel).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The authors do not consider physical attacks such as differential power analysis.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;is-this-a-valid-attacker-model&#34;&gt;Is this a valid attacker model?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;The authors mention power consumption analysis as physical attack, however,
it is possible to learn information about power consumption through software
on many real systems (e.g., battery information).&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-is-a-cache-probing-attack&#34;&gt;What is a cache probing attack?&lt;/h4&gt;

&lt;p&gt;The cache is shared between processes and hence one process can affect the
timing of another process&amp;rsquo; memory access operations in an observable way that
can be measured and potentially leak secret information.&lt;/p&gt;

&lt;h4 id=&#34;why-are-timing-channels-difficult-to-control&#34;&gt;Why are timing channels difficult to control?&lt;/h4&gt;

&lt;p&gt;Timing channels are difficult because secret information can affect timing in
many ways. For example, in software, a loop or an if statement with a secret
condition; in hardware, a shared cache as explained in the previous question.&lt;/p&gt;

&lt;h4 id=&#34;how-do-the-author-solve-timing-channels&#34;&gt;How do the author solve timing channels?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;They separate shared hardware resources (such as cache) into multiple
partitions corresponding to multiple security levels (such as high and low)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The hardware design follows a set of restrictions that prevent information in
the high partition (secret) from affecting the outcome or timing of information
in the low partition (public).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;They introduce labels for the Verilog HDL that define information flow policies
and enforce them at statically.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;why-is-if-h1-labeled-l-not-considered-a-timing-channel-even-though-h1-is-in-the-h-partition&#34;&gt;Why is &lt;code&gt;if (h1)&lt;/code&gt; (labeled L) not considered a timing channel even though h1 is in the H partition?&lt;/h4&gt;

&lt;p&gt;Because the timing of the if statement is determined by the existence of h1
and not the value of h1 hence no secret information can be learned by
measuring the execution time.&lt;/p&gt;

&lt;h4 id=&#34;what-are-dynamic-labels-and-why-are-they-needed&#34;&gt;What are dynamic labels and why are they needed?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Dynamic labels are labels that can change at run time and are expressed as
functions of some input.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;They allow for sharing hardware resources between multiple security levels.
For example, a register can have a dynamic label if during run time it can
store both a low and a high value.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Importantly, there are no static checks to ensure IFC safety even if
registers can take on different labels at run time. The static system ensure
that IFC cannot be violated.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-dependent-types&#34;&gt;What are dependent types?&lt;/h4&gt;

&lt;p&gt;They are types whose definition depend on some value. The authors define labels
with type that can be H or L depending on some value.&lt;/p&gt;

&lt;h4 id=&#34;what-is-implicit-declassification-how-do-they-solve-it&#34;&gt;What is implicit declassification? How do they solve it?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Implicit declassification happens when a secret value is copied into a
variable with a dynamic label that can change label from high to low at
run time and potentially leak the secret value.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;They insert code that dynamically deletes the content of the register if
implicit declassification is detected during the static analysis.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-label-channels&#34;&gt;What are label channels?&lt;/h4&gt;

&lt;p&gt;Label channels exist when the labels change dynamically and can consequently
encode and leak information.&lt;/p&gt;

&lt;h4 id=&#34;describe-two-approaches-to-mitigate-label-channels-and-their-shortcomings&#34;&gt;Describe two approaches to mitigate label channels and their shortcomings?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;No-sensitive upgrade: forbids raising a label in a high context. Rejects safe
code where a variable can safely raise its label in a high context if the
variable starts with a low label before the context.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Flow-sensitive: raises the label of a variable to the context label. Rejects
code where a label raise can cause a flow violation in a later code that
was caused by the raised label.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-do-the-authors-solve-label-channels&#34;&gt;How do the authors solve label channels?&lt;/h4&gt;

&lt;p&gt;They modify the above two to check the label of a variable at the merge
point of a branch and verify that the new label is at least as high as the
context label.&lt;/p&gt;

&lt;h4 id=&#34;how-do-the-authors-evaluate-secverilog&#34;&gt;How do the authors evaluate SecVerilog?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;They implement and verify a MIPS processor using SecVerilog and compare its
overhead against an unverified MIPS implemented with Verilog. They find that
the overhead in terms of delay, area, and power to be very small.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;They compare the performance of their secure MIPS against a regular MIPS
which shows significant overhead.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;why-is-their-mips-processor-slower-than-a-regular-mips-process&#34;&gt;Why is their MIPS processor slower than a regular MIPS process?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Their implementation includes timing channel protections added to the cache
and the pipeline.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;They partition the cache into high and low. When the timing label is high,
both high and low partitions can be accessed. However, when the timing
label is low, a cache access to the high always returns a miss. This clearly
adds overhead to the cache.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For the pipeline, they flush it whenever there is a change in the timing label
in order to disallow a high instruction from stalling a low instruction
which can leak information. This is also a clear performance overhead.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Ironclad Apps questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/ironclad-apps/</link>
      <pubDate>Thu, 17 Nov 2016 15:44:04 -0709</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/ironclad-apps/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Describe how declassification works in Ironclad.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why do you think they used UDP and not TCP in their apps?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The authors state that extending their verification to reason about
non-terminating programs is possible, with some work. (Currently you can
leak data via the termination channel, as we discussed in the LIO lecture.)
Do you agree? If so, describe what this extension might look like. If not,
explain why not.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Ironclad Apps</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/ironclad-apps/</link>
      <pubDate>Thu, 17 Nov 2016 01:37:21 -0702</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/ironclad-apps/</guid>
      <description>

&lt;p&gt;Author: Fucheng Gao&lt;/p&gt;

&lt;h4 id=&#34;where-was-this-published&#34;&gt;Where was this published?&lt;/h4&gt;

&lt;p&gt;OSDI, systems venue&lt;/p&gt;

&lt;h4 id=&#34;what-kind-of-need-is-satisfied-by-ironclad&#34;&gt;What kind of need is satisfied by Ironclad?&lt;/h4&gt;

&lt;p&gt;People want to assure their data secure when running apps in the could, without
trusting the cloud provider.&lt;/p&gt;

&lt;h4 id=&#34;what-s-the-shortcoming-of-previous-work-on-verification&#34;&gt;What&amp;rsquo;s the shortcoming of previous work on verification?&lt;/h4&gt;

&lt;p&gt;Currently software verification can provide strong guarantees, but the cost is
often high &amp;ndash; e.g., seL4 took over 20-person years.&lt;/p&gt;

&lt;h4 id=&#34;system-features&#34;&gt;System features&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;It can completely verify the software stack, which means it assume every part
of software is untrusted, e.g. OS, BIOS, etc.&lt;/li&gt;
&lt;li&gt;The verification is on low-level assembly, meaning some of the toolsets
(e.g., DafnyCC) need not not trusted.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;goals&#34;&gt;Goals&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Remote equivalence: A remote user should receive the same sequence
of messages as a user communicating with the app abstract state machine.&lt;/li&gt;
&lt;li&gt;Secure channel: Remote user can establish a secure channel to the app, in
the presence of an untrusted OS.&lt;/li&gt;
&lt;li&gt;Completeness: Every software component must be verified.&lt;/li&gt;
&lt;li&gt;Low level verification: verify the actual instruction to that are executed.&lt;/li&gt;
&lt;li&gt;Rapid development by systems programmers: Non-expert developers should be
able to rapidly develop a verified Ironclad app.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;non-goals&#34;&gt;Non-goals&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Compatibility&lt;/li&gt;
&lt;li&gt;Performance&lt;/li&gt;
&lt;li&gt;Covert-channels&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;main-techniques-used-by-ironclad&#34;&gt;Main techniques used by Ironclad&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Late launch: Run application in a protected environment&lt;/li&gt;
&lt;li&gt;Trusted computing: Tight software to a encryption key&lt;/li&gt;
&lt;li&gt;Software verification: Prove software action follows specification&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;threat-model&#34;&gt;Threat model&lt;/h4&gt;

&lt;p&gt;Provide security against software-based attackers, who may run arbitrary
software on machine before executing or after app executes. The adversary may
attack the BIOS, OS, etc.&lt;/p&gt;

&lt;p&gt;Ironclad only provides privacy and integrity; no liveness/DOS or consideration
for covert-channel attacks.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-tpm-trusted-platform-module-and-how-is-it-used-by-ironclad&#34;&gt;What is the TPM (Trusted Platform Module) and how is it used by Ironclad?&lt;/h4&gt;

&lt;p&gt;The TPM offers facilities for the secure generation of cryptographic keys,
random number generation, signing with the platform key, etc.&lt;/p&gt;

&lt;p&gt;The TPM is used by Ironclad to prove to the remote user that the app they think
is running is indeed that; i.e., the TPM is use for attestation. See
(TXT)[&lt;a href=&#34;https://en.wikipedia.org/wiki/Trusted_Execution_Technology&#34;&gt;https://en.wikipedia.org/wiki/Trusted_Execution_Technology&lt;/a&gt;] for modern usages.&lt;/p&gt;

&lt;h4 id=&#34;developer-workflow&#34;&gt;Developer workflow&lt;/h4&gt;

&lt;p&gt;Firsts, the developer write the high-level specification (trusted) and then
implements the app in Dafny (untrusted), using Hoare logic pre and post
conditions to make aid the verification. Using a specification translator, the
high-level spec will be translate to a BoogieX86 specification. The DafnyCC
complier will also compile the implementation into BoogieX86.  The verifier
will then verify if assembly code &amp;ldquo;matches&amp;rdquo; the spec. Finally, the trusted
assembler and linker produces the final binary.&lt;/p&gt;

&lt;h4 id=&#34;what-kind-of-specification-types-does-ironclad-rely-on&#34;&gt;What kind of specification types does Ironclad rely on?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Hardware specifications&lt;/li&gt;
&lt;li&gt;App Specifications&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-does-ironclad-simplify-hardware-specifications&#34;&gt;How does Ironclad simplify hardware specifications?&lt;/h4&gt;

&lt;p&gt;It only defines spec for the introductions it can reason about and uses in the
compilation stages; this is only slightly less than 60 instructions.&lt;/p&gt;

&lt;h4 id=&#34;how-does-ironclad-reduce-app-verification-cost&#34;&gt;How does Ironclad reduce app verification cost?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Preliminary verification: It performs a basic verification on Dafny code via
Z3. This lets developers quickly detect bugs when programming.&lt;/li&gt;
&lt;li&gt;Modular verification&lt;/li&gt;
&lt;li&gt;Shared verification&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;besides-functional-correctness-what-else-does-ironclad-prove&#34;&gt;Besides functional correctness what else does Ironclad prove?&lt;/h4&gt;

&lt;p&gt;They ensure privacy by proving noninterference. This is proved via Boogie&amp;rsquo;s
SymDiff.&lt;/p&gt;

&lt;h4 id=&#34;why-is-noninterference-not-usually-practical-for-real-apps&#34;&gt;Why is noninterference not usually practical for real apps?&lt;/h4&gt;

&lt;p&gt;Apps need to leak data. To this end, Ironclad introduced declassification via a
state machine.&lt;/p&gt;

&lt;h4 id=&#34;how-was-remote-equivalence-proved&#34;&gt;How was remote equivalence proved?&lt;/h4&gt;

&lt;p&gt;In short: they prove functional correctness for the declsssifier and noninterference for
the program up to the declassify statement and after it.&lt;/p&gt;

&lt;h4 id=&#34;what-feature-does-dafnycc-provide&#34;&gt;What feature does DafnyCC provide?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Type safety&lt;/li&gt;
&lt;li&gt;Array bound safety&lt;/li&gt;
&lt;li&gt;Transitive stack safety&lt;/li&gt;
&lt;li&gt;High-level property preservation&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-is-late-launch&#34;&gt;What is late-launch?&lt;/h4&gt;

&lt;p&gt;It resets the CPU to a known state, stores a measurement (hash) of the
in-memory code pointed to by the instruction’s argument, and jumps to that
code. After a late-launch, the hardware provides the program control of the CPU
and 64 KiB of protected memory.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Singularity</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/singularity/</link>
      <pubDate>Tue, 15 Nov 2016 01:37:21 -0703</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/singularity/</guid>
      <description>

&lt;p&gt;Author: Deian Stefan&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-motivation-behind-singularity-and-more-broadly-a-message-passing-os&#34;&gt;What is the motivation behind Singularity and, more broadly, a message passing OS?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Bugs/vulnerabilities in existing systems due to interaction between different
components. In the OS world, device drivers are plagued by vulnerabilities.&lt;/li&gt;
&lt;li&gt;Isolation between different components: bugs in one wont affect other&lt;/li&gt;
&lt;li&gt;In the real world, we want message passing for device drivers, browser
extensions, plugins, ets&lt;/li&gt;
&lt;li&gt;Low-level languages are prone to UAFs and memory leaks.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;They believe that these problems can be addressed by high-level languages and message passing.&lt;/p&gt;

&lt;p&gt;Shared messaging only &lt;em&gt;seems&lt;/em&gt; simple; in practice it gets complicated once you
need to worry about races. Locks and barriers are not easy to use.&lt;/p&gt;

&lt;h4 id=&#34;what-are-the-limitations-downsides-of-existing-message-passing-systems&#34;&gt;What are the limitations/downsides of existing message passing systems?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Complicated programming models&lt;/li&gt;
&lt;li&gt;Performance due to copying data&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-is-the-big-downside-of-high-level-languages&#34;&gt;What is the big downside of high-level languages?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;GC, and directly: performance&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;at-a-high-level-how-does-singularity-address-this&#34;&gt;At a high-level, how does Singularity address this?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;SIPs (software isolated processes) run in isolation from each other.

&lt;ul&gt;
&lt;li&gt;In general most things process handles are GCd.&lt;/li&gt;
&lt;li&gt;Can allocate data in the exchange heap to share with other processes. This
data is manually managed.&lt;/li&gt;
&lt;li&gt;No dynamically loaded code (can&amp;rsquo;t reason about ownership etc.)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Only communication between processes: channels.&lt;/li&gt;
&lt;li&gt;Can send scalars, channel end points and pointers on the exchange heap to
other SIPs.

&lt;ul&gt;
&lt;li&gt;Ownership model ensures memory safety.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;why-is-singularity-so-fast&#34;&gt;Why is Singularity so fast?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Context switching is cheap: no user-priv mode, no MMU to get in the way, all
isolation is done in software. Only marginally more expensive than a function
call.&lt;/li&gt;
&lt;li&gt;Message passing is cheap: no allocation, the 0-copy sends means only pointer
is sent and no data is copied. (Trade-off? programming model + flexibility)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-do-they-mean-when-they-say-memory-safety&#34;&gt;What do they mean when they say memory safety?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;No UAFs&lt;/li&gt;
&lt;li&gt;No memory leaks&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-do-they-address-this&#34;&gt;How do they address this?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Only one SIP can &lt;em&gt;own&lt;/em&gt; a block in the exchange heap.&lt;/li&gt;
&lt;li&gt;When you send pointer as message to another heap, they are now the owner of
this block. You can no longer use the pointer.&lt;/li&gt;
&lt;li&gt;They ensure this statically by tracking ownership at the language level:

&lt;ul&gt;
&lt;li&gt;You get ownership by allocating, as function parameter, or return value.&lt;/li&gt;
&lt;li&gt;You lose ownership when you call function or call delete.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Invariants: only 1 owner (UAF), owner must free (leak).&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-s-the-point-of-expose-and-what-can-go-wrong-without-it&#34;&gt;What&amp;rsquo;s the point of &lt;code&gt;expose&lt;/code&gt; and what can go wrong without it?&lt;/h4&gt;

&lt;p&gt;Transfer ownership of field from struct to function. Otherwise, we can have
issues like UAFs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void func(NetworkPacket* in ExHeap pk) {
  byte []  in ExHeap d = pkt-&amp;gt;data;
  f(pkt); // if f deletes pkt or if pkt-&amp;gt;data is deleted, etc. we crash below:
  d[32] = 44;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;why-does-singularity-have-channel-contracts-what-are-contracts-and-explain-2-issues-contracts-address-and-how-they-address-them&#34;&gt;Why does Singularity have channel contracts? What are contracts? And, explain 2 issues contracts address and how they address them.&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Homework question&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-is-the-role-of-the-tcell-t-constructor&#34;&gt;What is the role of the &lt;code&gt;TCell&amp;lt;T&amp;gt;&lt;/code&gt; constructor?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Homework question&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Singularity questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/singularity/</link>
      <pubDate>Tue, 15 Nov 2016 01:37:21 -0703</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/singularity/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Why does Singularity have channel contracts? What are contracts? And, explain 2 issues contracts address and how they address them.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What is the role of the &lt;code&gt;TCell&amp;lt;T&amp;gt;&lt;/code&gt; constructor? (That is, what problem was it designed to address?)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>S2E</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/s2e/</link>
      <pubDate>Mon, 14 Nov 2016 01:37:21 -0702</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/s2e/</guid>
      <description>

&lt;p&gt;Author: Brian Johannesmeyer&lt;/p&gt;

&lt;h4 id=&#34;what-conference-was-this-paper-in&#34;&gt;What conference was this paper in?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ASPLOS 2011, where it won best paper&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-types-of-analyses-can-a-developer-do-on-their-code&#34;&gt;What types of analyses can a developer do on their code?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Understand observed behavior&lt;/li&gt;
&lt;li&gt;Characterize future behavior

&lt;ul&gt;
&lt;li&gt;Should be able to do &amp;ldquo;what-if&amp;rdquo; analyses&lt;/li&gt;
&lt;li&gt;However this is difficult because systems are large and complex&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;what-three-properties-does-their-platform-offer&#34;&gt;What three properties does their platform offer?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Efficiently analyze &lt;em&gt;entire families of execution paths&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;i.e. More than one path of execution, and show that properties hold for all
paths in a system&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Maximize &lt;em&gt;realism&lt;/em&gt; by running the analyses in a real software stack

&lt;ul&gt;
&lt;li&gt;Take into account the whole environment surrounding a program&lt;/li&gt;
&lt;li&gt;Most approaches abstract away the environment behind a model, but that may
lose accuracy, and is also labor-intensive&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Ability to &lt;em&gt;directly analyze binaries&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;Access to source code is rarely feasible&lt;/li&gt;
&lt;li&gt;However, is this really a feature? Or are they &lt;em&gt;constrained&lt;/em&gt; to binaries?
This may not work on, e.g. direct JavaScript analysis.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;what-is-symbolic-execution&#34;&gt;What is symbolic execution?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Program analysis to determine what inputs cause each part of a program to execute&lt;/li&gt;
&lt;li&gt;Treat program as superposition of possible execution paths

&lt;ul&gt;
&lt;li&gt;e.g. &lt;code&gt;if(x&amp;gt;0) ... then ... else&lt;/code&gt; treated as superposition of two possible
paths: one for x&amp;gt;0 and one for x&amp;lt;=0.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;For some constraint (e.g. x&amp;gt;0), instead of allowing a variable to take on a
concrete value (e.g. x=5), it takes on a whole set of values (e.g. x:(0,+∞))&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-insight-makes-s2e-different-from-normal-symbolic-execution&#34;&gt;What insight makes S2E different from normal symbolic execution?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Often only some families of paths are of interest to developers (e.g. might
not care about analyzing kernel code)&lt;/li&gt;
&lt;li&gt;S2E can selectively choose what to symbolically execute by going back and
forth between multi-path mode (i.e. with symbolic values) and single-path
mode (i.e. with concrete values)&lt;/li&gt;
&lt;li&gt;Also, things can be thrown away in the analysis if we don&amp;rsquo;t care about it&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-are-symbolic-values-converted-to-concrete-values&#34;&gt;How are symbolic values converted to concrete values?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;By simply choosing a value from the symbolic set&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-are-concrete-values-converted-to-symbolic-values&#34;&gt;How are concrete values converted to symbolic values?&lt;/h4&gt;

&lt;p&gt;The symbolic value is constrained to whatever the concrete value was (e.g. x=5,
when originally x&amp;gt;0) to take into account any side effects x=4 may have had.
What can go wrong here?
- You lose a lot of information about the value later on when you convert back
  to a symbolic value, i.e. may overconstrain a value
- It affects completeness&lt;/p&gt;

&lt;h4 id=&#34;what-is-overconstraining&#34;&gt;What is overconstraining?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Constraining a value (whether by soft or hard constraints) so much that it
cannot go down future paths&lt;/li&gt;
&lt;li&gt;What is a soft constraint?

&lt;ul&gt;
&lt;li&gt;Constraint imposed by symbolic/concrete boundary (e.g. x:(0,+∞) -&amp;gt; x=5)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is a hard constraint?

&lt;ul&gt;
&lt;li&gt;Constraint imposed by code (e.g. x&amp;gt;0 in &lt;code&gt;if(x&amp;gt;0)...then...else&lt;/code&gt;)
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-is-the-process-of-converting-from-symbolic-to-concrete-values-and-back-processed&#34;&gt;How is the process of converting from symbolic to concrete values and back processed?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;According to an execution consistency model&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;let-s-define-the-parts-of-an-execution-consistency-model&#34;&gt;Let’s define the parts of an execution consistency model…&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Analysis spaces

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;System&lt;/strong&gt;: complete software system under analysis, including programs,
libraries, OS, etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unit&lt;/strong&gt;: the part of the system to be analyzed&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Environment&lt;/strong&gt;: the part of the system that’s not analyzed&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Path types (look at figure on top right of page 4)

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Statically feasible&lt;/strong&gt;: there exists a possible path in the system&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Locally feasible&lt;/strong&gt;: there exists a possible path in the system that’s
consistent with data-related constraints in the unit&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Globally feasible&lt;/strong&gt;: there exists a possible path in the system that’s
consistent with all data-related constraints (i.e. in both the unit and the
environment)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Metrics

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Complete&lt;/strong&gt;: every path through the unit that’s globally feasible will
eventually be discovered by exploration done on that unit&lt;/li&gt;
&lt;li&gt;i.e. all execution paths can be discovered&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consistent&lt;/strong&gt;: every path through the unit has a corresponding globally
feasible path through the system&lt;/li&gt;
&lt;li&gt;i.e. the unit can correctly run on the system&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Why do we care about completeness and consistency?

&lt;ul&gt;
&lt;li&gt;We can do different things with their tradeoffs (see table 1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;strict-consistency&#34;&gt;Strict consistency&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Based on globally feasibility

&lt;ul&gt;
&lt;li&gt;Admits only globally feasible paths, i.e. only allows paths that are
consistent with ALL data-related constraints&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is &lt;em&gt;Strictly Consistent Concrete Execution (SC-CE)&lt;/em&gt;?

&lt;ul&gt;
&lt;li&gt;System is a black box&lt;/li&gt;
&lt;li&gt;Only a single execution path; executed non-symbolically&lt;/li&gt;
&lt;li&gt;Used for:&lt;/li&gt;
&lt;li&gt;Units tests, fuzzing&lt;/li&gt;
&lt;li&gt;Valgrind&lt;/li&gt;
&lt;li&gt;Anything that executes along a single path, generated by user-specified
concrete inputs&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;Doesn&amp;rsquo;t symbolically track anything&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is &lt;em&gt;Strictly Consistent Unit-level Execution (SC-UE)&lt;/em&gt;?

&lt;ul&gt;
&lt;li&gt;Environment treated as a black box&lt;/li&gt;
&lt;li&gt;Exploration engine allowed to gather and use information internal to the unit&lt;/li&gt;
&lt;li&gt;Used by: symbolic and concolic execution tools&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;Symbolic value turned into concrete value when units calls environment&lt;/li&gt;
&lt;li&gt;When environment returns back to unit, the soft constraint it created
becomes a hard constraint&lt;/li&gt;
&lt;li&gt;This hinders completeness&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is &lt;em&gt;Strictly Consistent System-level Execution (SC-SE)&lt;/em&gt;?

&lt;ul&gt;
&lt;li&gt;Nothing is a black box&lt;/li&gt;
&lt;li&gt;Exploration engine allowed to gather and use information about the entire
system&lt;/li&gt;
&lt;li&gt;Limited by: path explosion problem&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;Symbolic values everywhere&lt;/li&gt;
&lt;li&gt;Path explosion

&lt;ul&gt;
&lt;li&gt;Can use heuristics to prioritize path exploration,&lt;/li&gt;
&lt;li&gt;Or employ incremental symbolic execution
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;local-consistency-lc&#34;&gt;Local Consistency (LC)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Avoids exploring all paths in the environment&lt;/li&gt;
&lt;li&gt;Replaces results of calls to the environment with the symbolic values that
represent possible valid results

&lt;ul&gt;
&lt;li&gt;e.g. &lt;code&gt;write(fd, buf,count)&lt;/code&gt; can return any integer between -1 and count&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Allows for inconsistencies in the environment while keeping the state of the
unit internally consistent&lt;/li&gt;
&lt;li&gt;No false positives because the internal state is consistent&lt;/li&gt;
&lt;li&gt;Implementation

&lt;ul&gt;
&lt;li&gt;At environment-boundary, concrete output value is turned into a symbolic
value based on the function’s specification&lt;/li&gt;
&lt;li&gt;However, if symbolic data is written to the environment, it may become
inconsistent&lt;/li&gt;
&lt;li&gt;If a branch in the environment depends on symbolic data, the execution
path must be aborted
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;relaxed-consistency&#34;&gt;Relaxed consistency&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Disadvantages

&lt;ul&gt;
&lt;li&gt;Inconsistent in the general case&lt;/li&gt;
&lt;li&gt;Internal state of the unit may be inconsistent, producing false positives&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Advantage: Performance&lt;/li&gt;
&lt;li&gt;What is &lt;em&gt;Overapproximate Consistency (RC-OC)&lt;/em&gt;?

&lt;ul&gt;
&lt;li&gt;Path exploration can follow paths through the unit while completely
ignoring the constraints&lt;/li&gt;
&lt;li&gt;E.g. call to write() would not bound the return value&lt;/li&gt;
&lt;li&gt;Thus, violates the specification of the write system call&lt;/li&gt;
&lt;li&gt;Used for: reverse engineering&lt;/li&gt;
&lt;li&gt;Why is it used for reverse engineering?&lt;/li&gt;
&lt;li&gt;See 6.1.2 - They fake the hardware in order to understand what the
drivers are doing&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;At unit/environment boundaries, converts concrete values into
unconstrained symbolic values&lt;/li&gt;
&lt;li&gt;E.g. All possible values that write() could return, rather values it
should return&lt;/li&gt;
&lt;li&gt;Gives completeness at the expense of consistency&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is &lt;em&gt;CFG Consistency (RC-CC)&lt;/em&gt;?

&lt;ul&gt;
&lt;li&gt;Exploration engine allowed to change any part of the system state as long
as the explored paths correspond to paths in the unit’s inter-procedural
CFG&lt;/li&gt;
&lt;li&gt;Used for: disassembling obfuscated and/or encrypted code&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;Pursues all outcomes of every branch, regardless of path constraints&lt;/li&gt;
&lt;li&gt;Thus, follows all edges in the unit&amp;rsquo;s inter-procedural CFG&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;s2e-api&#34;&gt;S2E API&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Tables 2 and 3 give the best overview of what core events can be used to
develop analysis tools, and an idea of the interface to the &lt;em&gt;ExecState&lt;/em&gt; object.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;How are bugs that may result from slower system execution in symbolic mode
mitigated?

&lt;ul&gt;
&lt;li&gt;The virtual clock is slowed down when symbolically executing a state&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Definitions

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Virtualization&lt;/strong&gt;: creating a software-based (or virtual) representation
of something rather than a physical one&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dynamic binary translation&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;Emulation of one instruction set by another through translation of binary
code (e.g. ARM -&amp;gt; x86)&lt;/li&gt;
&lt;li&gt;S2E turns blocks of guest code into corresponding host code&lt;/li&gt;
&lt;li&gt;Dynamic means it happens as it executes

&lt;ul&gt;
&lt;li&gt;Translates code as it is explored&lt;/li&gt;
&lt;li&gt;Typically one basic block is translated at a time then cached&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Copy-on-write&lt;/strong&gt;: improves performance by only copying an object when the
copy or the original is written to&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;evaluation&#34;&gt;Evaluation&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;What 3 questions did they try to answer and how did they go about evaluating them?

&lt;ol&gt;
&lt;li&gt;Is S2E a &lt;em&gt;general&lt;/em&gt; platform for building tools?&lt;/li&gt;
&lt;li&gt;Showed that S2E can be used to build 3 very different tools (section 6.1).&lt;/li&gt;
&lt;li&gt;Does S2E have reasonable &lt;em&gt;performance&lt;/em&gt;?&lt;/li&gt;
&lt;li&gt;Discussed its overhead in both concrete mode (~6x) and symbolic mode
(~78x) and ways to reduce it (section 6.2).&lt;/li&gt;
&lt;li&gt;What are the &lt;em&gt;tradeoffs&lt;/em&gt; between choosing different execution consistency
models?&lt;/li&gt;
&lt;li&gt;Gave figures showing code coverage, memory usage, and constraint solving
time based on which consistency model was used (section 6.3).&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;What is Table 4 trying to convey? Do it do so successfully?

&lt;ul&gt;
&lt;li&gt;It is trying to convey the usability of S2E: that it is straightforward to
instrument and create custom analysis tools. However there are a few things
that are wrong with their approach:&lt;/li&gt;
&lt;li&gt;First, they built DDT and RevNIC previously, so they already understand
the ins and outs of developing these types of analysis tools. Thus, their
development time should naturally be dramatically shorter because they&amp;rsquo;ve
already implemented a similar system. This confounds their development
time results.&lt;/li&gt;
&lt;li&gt;In addition, not many details are given for their calculation of
&amp;ldquo;person-hours&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Also, it mentions in Table 4&amp;rsquo;s caption that &amp;ldquo;10 KLOC of offline analysis
code is reused in [REV+]&amp;ldquo;. However, that element of the table does not
have those 10 KLOC added to it. If those 10 KLOC count against the
previous implementation (i.e. 57,000 LOC), it should count against the
new implementation too (i.e. 10,580 LOC instead of 580 LOC).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Even after going through the tradeoffs of different consistency models in
section 6.2, I don&amp;rsquo;t think it would be immediately clear to developers which
model they should use.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Microchex</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/uchex/</link>
      <pubDate>Mon, 07 Nov 2016 01:37:21 -0702</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/uchex/</guid>
      <description>

&lt;p&gt;Author: Gary Soeller&lt;/p&gt;

&lt;h4 id=&#34;what-problem-does-uchex-address&#34;&gt;What problem does uchex address?&lt;/h4&gt;

&lt;p&gt;Static bug checkers require a full compiler front end (lexer and parser) to build
a complete grammar. This often requires an enormous engineering effort and is
not easy for developers to write their own static checker.&lt;/p&gt;

&lt;h4 id=&#34;what-is-uchex&#34;&gt;What is uchex?&lt;/h4&gt;

&lt;p&gt;uchex is a framework for easily writing language agnostic static bug checkers.&lt;/p&gt;

&lt;h4 id=&#34;how-does-uchex-solve-the-problem-addressed&#34;&gt;How does uchex solve the problem addressed?&lt;/h4&gt;

&lt;p&gt;uchex solves the problem by using a &lt;em&gt;micro-grammar&lt;/em&gt;: a grammar which contains a
subset of the grammar being parsed. uchex allows developers to write a checker
for a subset of the grammar allowing them the ability to easily write a
checker.  A major benefit of uchex checkers is that they are language agnostic.
Furthermore, micro-grammars can also be language agnostic since they only parse
a small fraction of grammars. This allows code to be reused easily.&lt;/p&gt;

&lt;h4 id=&#34;what-are-the-properties-of-a-micro-grammar&#34;&gt;What are the properties of a micro-grammar?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;The original grammar is a subset of the micro-grammar.&lt;/li&gt;
&lt;li&gt;The original grammar and micro-grammar have the same structure.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Why are these two properties important?&lt;/p&gt;

&lt;h4 id=&#34;how-does-the-uchex-parser-differ-from-a-traditional-parser&#34;&gt;How does the uchex parser differ from a traditional parser?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Sliding window: This allows the parser to continue when it does not
recognize a token.&lt;/li&gt;
&lt;li&gt;Wildcard: Allows the parser to match anything.&lt;/li&gt;
&lt;li&gt;Commit points: Allows the parser to stop sliding forward once an important
token is reached for badly written micro-grammars.&lt;/li&gt;
&lt;li&gt;Compositional parsers: Allows parsers to be chained together. (Though
parsec-based parsers often have this property.)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;what-is-a-belief-style-checker&#34;&gt;What is a belief-style checker?&lt;/h4&gt;

&lt;p&gt;A type of checker that makes assumptions about the code. While traversing the
code, if the checker can contradict an assumption, then there is an error.&lt;/p&gt;

&lt;p&gt;All of the example checkers they present use belief-style, but they are not
necessarily limited to this.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-algorithm-for-the-null-pointer-checker&#34;&gt;What is the algorithm for the null pointer checker?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;When a pointer is dereferenced, it is added to a &amp;ldquo;not null&amp;rdquo; set. The &amp;ldquo;not
null&amp;rdquo; set is the set of &amp;ldquo;beliefs&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Whenever a not null check is made, the pointer is looked up in the &amp;ldquo;not
null&amp;rdquo; set.&lt;/li&gt;
&lt;li&gt;If pointer is set, a belief is contradicted indicating that there is an
error.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The null pointer checker uses forward data flow analysis. This allows the
checker to know information about the past. Other checkers use backward data
flow analysis which gives the checker information about the future.&lt;/p&gt;

&lt;h4 id=&#34;what-type-of-bugs-can-uchex-catch&#34;&gt;What type of bugs can uchex catch?&lt;/h4&gt;

&lt;p&gt;Intra-procedural. This is the most simple type of bug because it requires no
context outside of the function.&lt;/p&gt;

&lt;h4 id=&#34;what-types-of-bugs-does-uchex-not-catch&#34;&gt;What types of bugs does uchex not catch?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Those that require inter-procedural analysis.  What are inter procedural
checkers and what can these catch that uchex can&amp;rsquo;t?&lt;/li&gt;
&lt;li&gt;Those that require alias tracking. What is alias tracking and why is this
hard to support?&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;what-type-of-grammar-is-uchex-able-to-parse-and-why-is-this-important&#34;&gt;What type of grammar is uchex able to parse and why is this important?&lt;/h4&gt;

&lt;p&gt;uchex can parse LL(k) grammars. There are limitations with parsers so it is
important to know which type of parser is being used. One limitation of LL(k) is
that left-recursion can not be parsed. Therefore, the developer must eliminate
it from the grammar.&lt;/p&gt;

&lt;h4 id=&#34;how-is-uchex-evaluated&#34;&gt;How is uchex evaluated?&lt;/h4&gt;

&lt;p&gt;uchex is evaluated against an undisclosed industrial static checker (called
&lt;em&gt;SystemX&lt;/em&gt; in the paper). Both checkers are run on the same codebases and the
results are compared by counting the number and overlap of bugs found. It is
important to note that uchex and SystemX can use each others results as ground
truth. This way they can be used in conjunction to improve each other.&lt;/p&gt;

&lt;p&gt;uchex is also evaluated to demonstrate simplicity and ease of developing new
checkers. The only metric used is lines of code. This does not say much so it
should be taken with a grain of salt.&lt;/p&gt;

&lt;p&gt;Deian, on last point: if you&amp;rsquo;ve written checkers you&amp;rsquo;ll find that LOC is pretty
reasonable. Managing giant ASTs and state in existing frameworks is super hard.
Moreover, I think for this we can partially appeal to authority: Dawson has
done work on checkers for decades.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Microchex questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/uchex/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0709</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/uchex/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What are false negatives? Do they matter? How can you figure out a system&amp;rsquo;s
false negatives?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;#181;chex shows that by ignoring parts of a language we can write effective
checkers considerably more easily. Give another example or two of a domain
or problem where ignoring certain things (i.e., approximating) may lead to
more efficient but still effective solution.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>COWL questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/cowl/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0708</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/cowl/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Why are labeled blobs crucial for making COWL practical? (Can&amp;rsquo;t a context
just raise its label to ensure that a receiving context is at least as
sensitive before sending it data? Come up with a scenario where this
wouldn&amp;rsquo;t work.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why does COWL not allow arbitrary JavaScript objects to be labeled and sent
via &lt;code&gt;postMessage&lt;/code&gt;? (I.e., why must objects be &lt;em&gt;structurally clonable&lt;/em&gt;?)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;One can think of COWL as an adaptation of LIO for the browser. But, unlike
for LIO, we cannot prove termination-sensitive non-interference (TSNI) for
COWL. Recall what TSNI is and explain why we can&amp;rsquo;t prove this COWL.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Chrome extension system questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/chrome-extension-system/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0707</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/chrome-extension-system/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&amp;ldquo;Content scripts run in the same process as their associated web pages.&amp;rdquo;
What makes it difficult to run them in separate processes? Give 2 reasons.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Explain how a malicious extension that has the privilege to read/write
data on any origin can steal a user&amp;rsquo;s banking data even if they never visit
evil.com.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>NaCl questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/nacl/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0706</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/nacl/</guid>
      <description>&lt;p&gt;Answer any 3:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What the purpose of the inner sandbox? What guarantees does it provide and
how does NaCl implement it?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What the purpose of the outer sandbox? What guarantees does it provide and
how does NaCl implement it?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why did NaCl take the approach of statically verifying that a piece of x86
is safe instead of providing a trusted compiler approach?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why is it not possible to dynamically load a library with NaCl? What makes
this hard to do?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why does NaCl not support JITed language runtimes?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Verena questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/verena/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0705</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/verena/</guid>
      <description>&lt;p&gt;Answer any 2:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What is Verena&amp;rsquo;s attacker model? Don&amp;rsquo;t just rehash what&amp;rsquo;s in the paper.
Instead think about different stages (e.g., server was not compromised then
it was compromised, what can the attacker do?).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Describe the components that make up Verena&amp;rsquo;s architecture and their
individual roles.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What are &lt;em&gt;trust contexts&lt;/em&gt; and why are they necessary?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How do Verena&amp;rsquo;s integrity guarantees differ from Hails&amp;rsquo; integrity
guarantees?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>