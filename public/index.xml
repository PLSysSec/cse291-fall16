<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CSE 291</title>
    <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/</link>
    <description>Recent content on CSE 291</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</managingEditor>
    <webMaster>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</webMaster>
    <lastBuildDate>Tue, 15 Nov 2016 01:37:21 -0703</lastBuildDate>
    <atom:link href="https://cseweb.ucsd.edu/~dstefan/cse291-fall16/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Singularity</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/singularity/</link>
      <pubDate>Tue, 15 Nov 2016 01:37:21 -0703</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/singularity/</guid>
      <description>

&lt;p&gt;Author: Deian Stefan&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-motivation-behind-singularity-and-more-broadly-a-message-passing-os&#34;&gt;What is the motivation behind Singularity and, more broadly, a message passing OS?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Bugs/vulnerabilities in existing systems due to interaction between different
components. In the OS world, device drivers are plagued by vulnerabilities.&lt;/li&gt;
&lt;li&gt;Isolation between different components: bugs in one wont affect other&lt;/li&gt;
&lt;li&gt;In the real world, we want message passing for device drivers, browser
extensions, plugins, ets&lt;/li&gt;
&lt;li&gt;Low-level languages are prone to UAFs and memory leaks.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;They believe that these problems can be addressed by high-level languages and message passing.&lt;/p&gt;

&lt;p&gt;Shared messaging only &lt;em&gt;seems&lt;/em&gt; simple; in practice it gets complicated once you
need to worry about races. Locks and barriers are not easy to use.&lt;/p&gt;

&lt;h4 id=&#34;what-are-the-limitations-downsides-of-existing-message-passing-systems&#34;&gt;What are the limitations/downsides of existing message passing systems?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Complicated programming models&lt;/li&gt;
&lt;li&gt;Performance due to copying data&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-is-the-big-downside-of-high-level-languages&#34;&gt;What is the big downside of high-level languages?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;GC, and directly: performance&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;at-a-high-level-how-does-singularity-address-this&#34;&gt;At a high-level, how does Singularity address this?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;SIPs (software isolated processes) run in isolation from each other.

&lt;ul&gt;
&lt;li&gt;In general most things process handles are GCd.&lt;/li&gt;
&lt;li&gt;Can allocate data in the exchange heap to share with other processes. This
data is manually managed.&lt;/li&gt;
&lt;li&gt;No dynamically loaded code (can&amp;rsquo;t reason about ownership etc.)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Only communication between processes: channels.&lt;/li&gt;
&lt;li&gt;Can send scalars, channel end points and pointers on the exchange heap to
other SIPs.

&lt;ul&gt;
&lt;li&gt;Ownership model ensures memory safety.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;why-is-singularity-so-fast&#34;&gt;Why is Singularity so fast?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Context switching is cheap: no user-priv mode, no MMU to get in the way, all
isolation is done in software. Only marginally more expensive than a function
call.&lt;/li&gt;
&lt;li&gt;Message passing is cheap: no allocation, the 0-copy sends means only pointer
is sent and no data is copied. (Trade-off? programming model + flexibility)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-do-they-mean-when-they-say-memory-safety&#34;&gt;What do they mean when they say memory safety?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;No UAFs&lt;/li&gt;
&lt;li&gt;No memory leaks&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-do-they-address-this&#34;&gt;How do they address this?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Only one SIP can &lt;em&gt;own&lt;/em&gt; a block in the exchange heap.&lt;/li&gt;
&lt;li&gt;When you send pointer as message to another heap, they are now the owner of
this block. You can no longer use the pointer.&lt;/li&gt;
&lt;li&gt;They ensure this statically by tracking ownership at the language level:

&lt;ul&gt;
&lt;li&gt;You get ownership by allocating, as function parameter, or return value.&lt;/li&gt;
&lt;li&gt;You lose ownership when you call function or call delete.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Invariants: only 1 owner (UAF), owner must free (leak).&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-s-the-point-of-expose-and-what-can-go-wrong-without-it&#34;&gt;What&amp;rsquo;s the point of &lt;code&gt;expose&lt;/code&gt; and what can go wrong without it?&lt;/h4&gt;

&lt;p&gt;Transfer ownership of field from struct to function. Otherwise, we can have
issues like UAFs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void func(NetworkPacket* in ExHeap pk) {
  byte []  in ExHeap d = pkt-&amp;gt;data;
  f(pkt); // if f deletes pkt or if pkt-&amp;gt;data is deleted, etc. we crash below:
  d[32] = 44;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;why-does-singularity-have-channel-contracts-what-are-contracts-and-explain-2-issues-contracts-address-and-how-they-address-them&#34;&gt;Why does Singularity have channel contracts? What are contracts? And, explain 2 issues contracts address and how they address them.&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Homework question&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-is-the-role-of-the-tcell-t-constructor&#34;&gt;What is the role of the &lt;code&gt;TCell&amp;lt;T&amp;gt;&lt;/code&gt; constructor?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Homework question&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Singularity questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/singularity/</link>
      <pubDate>Tue, 15 Nov 2016 01:37:21 -0703</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/singularity/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Why does Singularity have channel contracts? What are contracts? And, explain 2 issues contracts address and how they address them.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What is the role of the &lt;code&gt;TCell&amp;lt;T&amp;gt;&lt;/code&gt; constructor? (That is, what problem was it designed to address?)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Microchex</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/uchex/</link>
      <pubDate>Mon, 07 Nov 2016 01:37:21 -0702</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/uchex/</guid>
      <description>

&lt;p&gt;Author: Gary Soeller&lt;/p&gt;

&lt;h4 id=&#34;what-problem-does-uchex-address&#34;&gt;What problem does uchex address?&lt;/h4&gt;

&lt;p&gt;Static bug checkers require a full compiler front end (lexer and parser) to build
a complete grammar. This often requires an enormous engineering effort and is
not easy for developers to write their own static checker.&lt;/p&gt;

&lt;h4 id=&#34;what-is-uchex&#34;&gt;What is uchex?&lt;/h4&gt;

&lt;p&gt;uchex is a framework for easily writing language agnostic static bug checkers.&lt;/p&gt;

&lt;h4 id=&#34;how-does-uchex-solve-the-problem-addressed&#34;&gt;How does uchex solve the problem addressed?&lt;/h4&gt;

&lt;p&gt;uchex solves the problem by using a &lt;em&gt;micro-grammar&lt;/em&gt;: a grammar which contains a
subset of the grammar being parsed. uchex allows developers to write a checker
for a subset of the grammar allowing them the ability to easily write a
checker.  A major benefit of uchex checkers is that they are language agnostic.
Furthermore, micro-grammars can also be language agnostic since they only parse
a small fraction of grammars. This allows code to be reused easily.&lt;/p&gt;

&lt;h4 id=&#34;what-are-the-properties-of-a-micro-grammar&#34;&gt;What are the properties of a micro-grammar?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;The original grammar is a subset of the micro-grammar.&lt;/li&gt;
&lt;li&gt;The original grammar and micro-grammar have the same structure.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Why are these two properties important?&lt;/p&gt;

&lt;h4 id=&#34;how-does-the-uchex-parser-differ-from-a-traditional-parser&#34;&gt;How does the uchex parser differ from a traditional parser?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Sliding window: This allows the parser to continue when it does not
recognize a token.&lt;/li&gt;
&lt;li&gt;Wildcard: Allows the parser to match anything.&lt;/li&gt;
&lt;li&gt;Commit points: Allows the parser to stop sliding forward once an important
token is reached for badly written micro-grammars.&lt;/li&gt;
&lt;li&gt;Compositional parsers: Allows parsers to be chained together. (Though
parsec-based parsers often have this property.)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;what-is-a-belief-style-checker&#34;&gt;What is a belief-style checker?&lt;/h4&gt;

&lt;p&gt;A type of checker that makes assumptions about the code. While traversing the
code, if the checker can contradict an assumption, then there is an error.&lt;/p&gt;

&lt;p&gt;All of the example checkers they present use belief-style, but they are not
necessarily limited to this.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-algorithm-for-the-null-pointer-checker&#34;&gt;What is the algorithm for the null pointer checker?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;When a pointer is dereferenced, it is added to a &amp;ldquo;not null&amp;rdquo; set. The &amp;ldquo;not
null&amp;rdquo; set is the set of &amp;ldquo;beliefs&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Whenever a not null check is made, the pointer is looked up in the &amp;ldquo;not
null&amp;rdquo; set.&lt;/li&gt;
&lt;li&gt;If pointer is set, a belief is contradicted indicating that there is an
error.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The null pointer checker uses forward data flow analysis. This allows the
checker to know information about the past. Other checkers use backward data
flow analysis which gives the checker information about the future.&lt;/p&gt;

&lt;h4 id=&#34;what-type-of-bugs-can-uchex-catch&#34;&gt;What type of bugs can uchex catch?&lt;/h4&gt;

&lt;p&gt;Intra-procedural. This is the most simple type of bug because it requires no
context outside of the function.&lt;/p&gt;

&lt;h4 id=&#34;what-types-of-bugs-does-uchex-not-catch&#34;&gt;What types of bugs does uchex not catch?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Those that require inter-procedural analysis.  What are inter procedural
checkers and what can these catch that uchex can&amp;rsquo;t?&lt;/li&gt;
&lt;li&gt;Those that require alias tracking. What is alias tracking and why is this
hard to support?&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;what-type-of-grammar-is-uchex-able-to-parse-and-why-is-this-important&#34;&gt;What type of grammar is uchex able to parse and why is this important?&lt;/h4&gt;

&lt;p&gt;uchex can parse LL(k) grammars. There are limitations with parsers so it is
important to know which type of parser is being used. One limitation of LL(k) is
that left-recursion can not be parsed. Therefore, the developer must eliminate
it from the grammar.&lt;/p&gt;

&lt;h4 id=&#34;how-is-uchex-evaluated&#34;&gt;How is uchex evaluated?&lt;/h4&gt;

&lt;p&gt;uchex is evaluated against an undisclosed industrial static checker (called
&lt;em&gt;SystemX&lt;/em&gt; in the paper). Both checkers are run on the same codebases and the
results are compared by counting the number and overlap of bugs found. It is
important to note that uchex and SystemX can use each others results as ground
truth. This way they can be used in conjunction to improve each other.&lt;/p&gt;

&lt;p&gt;uchex is also evaluated to demonstrate simplicity and ease of developing new
checkers. The only metric used is lines of code. This does not say much so it
should be taken with a grain of salt.&lt;/p&gt;

&lt;p&gt;Deian, on last point: if you&amp;rsquo;ve written checkers you&amp;rsquo;ll find that LOC is pretty
reasonable. Managing giant ASTs and state in existing frameworks is super hard.
Moreover, I think for this we can partially appeal to authority: Dawson has
done work on checkers for decades.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Microchex questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/uchex/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0709</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/uchex/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What are false negatives? Do they matter? How can you figure out a system&amp;rsquo;s
false negatives?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;#181;chex shows that by ignoring parts of a language we can write effective
checkers considerably more easily. Give another example or two of a domain
or problem where ignoring certain things (i.e., approximating) may lead to
more efficient but still effective solution.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>COWL questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/cowl/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0708</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/cowl/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Why are labeled blobs crucial for making COWL practical? (Can&amp;rsquo;t a context
just raise its label to ensure that a receiving context is at least as
sensitive before sending it data? Come up with a scenario where this
wouldn&amp;rsquo;t work.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why does COWL not allow arbitrary JavaScript objects to be labeled and sent
via &lt;code&gt;postMessage&lt;/code&gt;? (I.e., why must objects be &lt;em&gt;structurally clonable&lt;/em&gt;?)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;One can think of COWL as an adaptation of LIO for the browser. But, unlike
for LIO, we cannot prove termination-sensitive non-interference (TSNI) for
COWL. Recall what TSNI is and explain why we can&amp;rsquo;t prove this COWL.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Chrome extension system questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/chrome-extension-system/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0707</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/chrome-extension-system/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&amp;ldquo;Content scripts run in the same process as their associated web pages.&amp;rdquo;
What makes it difficult to run them in separate processes? Give 2 reasons.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Explain how a malicious extension that has the privilege to read/write
data on any origin can steal a user&amp;rsquo;s banking data even if they never visit
evil.com.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>NaCl questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/nacl/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0706</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/nacl/</guid>
      <description>&lt;p&gt;Answer any 3:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What the purpose of the inner sandbox? What guarantees does it provide and
how does NaCl implement it?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What the purpose of the outer sandbox? What guarantees does it provide and
how does NaCl implement it?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why did NaCl take the approach of statically verifying that a piece of x86
is safe instead of providing a trusted compiler approach?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why is it not possible to dynamically load a library with NaCl? What makes
this hard to do?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why does NaCl not support JITed language runtimes?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Verena questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/verena/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0705</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/verena/</guid>
      <description>&lt;p&gt;Answer any 2:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What is Verena&amp;rsquo;s attacker model? Don&amp;rsquo;t just rehash what&amp;rsquo;s in the paper.
Instead think about different stages (e.g., server was not compromised then
it was compromised, what can the attacker do?).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Describe the components that make up Verena&amp;rsquo;s architecture and their
individual roles.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What are &lt;em&gt;trust contexts&lt;/em&gt; and why are they necessary?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How do Verena&amp;rsquo;s integrity guarantees differ from Hails&amp;rsquo; integrity
guarantees?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Hails questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/hails/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0704</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/hails/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Does Hails suffer from the external timing channel? If so, explain the
attack. If not, explain why this is not a concern. Consider the scenario
where an attacker is able to execute code server-side (e.g., as part of a
VC).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hails relies on COWL to enforce IFC in the browser. Suppose that was not the
case. Can you think of a way of addressing leaks due to untrusted HTML using
a server-side only solution? (&lt;em&gt;Hint:&lt;/em&gt; you may want to look at the resin
assignment for inspiration.) Bonus: What about untrusted JavaScript?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why did Hails eventually move from policies as pure functions (&lt;code&gt;Document -&amp;gt;
Label&lt;/code&gt;) to side-effecting ones (&lt;code&gt;Document -&amp;gt; LIO Label&lt;/code&gt;)?  What is a
negative trade-offs due to this?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Resin questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/resin/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0704</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/resin/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;An alternative approach to hacking the runtime to implement Resin is to use
code rewriting, i.e., rewrite applications to perform the data flow tracking
inline. What are 2-3 challenges with this approach? (Hint: some language
features may make this more difficult than others.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What are some advantages and disadvantages to Resin&amp;rsquo;s policy specification
approach when compared to label based approaches like LIO?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>LIO questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/lio/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0702</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/lio/</guid>
      <description>&lt;p&gt;Please answer any 2 questions from the following list. We will discuss all of
them in class.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;LIO has a notion of clearance. Why? What is the purpose of clearance at a
high level?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How does LIO side-step the &lt;em&gt;implicit flows problem&lt;/em&gt;? What&amp;rsquo;s the downside to
the approach?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What is the difference between the termination channel, the internal timing
channel, and the external timing channel?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How can hardware features such as the cache be used to re-introduce the
internal timing channel?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;LIO only mitigates the external timing channel. Can you think of a way to
eliminate the channel? And what is the trade-off to your approach?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For some of these you may want to look at the journal version of the
&lt;a href=&#34;https://cseweb.ucsd.edu/~dstefan/pubs/stefan:2012:flexible.pdf&#34;&gt;sequential LIO
system&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JIF questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/jif/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0700</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/jif/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What is the key difference between IFC and discretionary access
control or capabilities?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What are the benefits of enforcing IFC statically? (Why doesn&amp;rsquo;t JIF take the
dynamic route?)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>COWL</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/cowl/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0709</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/cowl/</guid>
      <description>

&lt;p&gt;Author: Rohit Jha&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-motivation-behind-cowl&#34;&gt;What is the motivation behind COWL?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Flexibility vs privacy&lt;/li&gt;
&lt;li&gt;MAC-based confinement better than DAC&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;at-a-high-level-what-does-cowl-do&#34;&gt;At a high-level, what does COWL do?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;COWL is a robust JavaScript confinement system for modern web browsers.&lt;/li&gt;
&lt;li&gt;COWL introduces label-based MAC to browsing contexts (pages, iframes, etc.)
in a way that is fully backward-compatible with legacy web content&lt;/li&gt;
&lt;li&gt;Prevents information leaks&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-the-design-requirements-for-cowl&#34;&gt;What are the design requirements for COWL?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;MAC with:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Symmetric confinement: two mutually distrusting scripts can each confine
the other’s use of data they send one another&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hierarchical confinement: allows any developer to confine untrusted code,
and confinement can be nested to arbitrary depths&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Delegation: allows a developer explicitly to confer the privileges of one
execution context on a separate execution context&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;

&lt;h4 id=&#34;what-are-some-browser-security-policies-and-concepts-explained-in-the-paper&#34;&gt;What are some browser security policies and concepts explained in the paper?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Browsing contexts&lt;/li&gt;
&lt;li&gt;Same-Origin Policy (SOP): how does SOP not prevent data from being disclosed
to foreign origins?&lt;/li&gt;
&lt;li&gt;Content Security Policy (CSP): what are the limitations of CSP?&lt;/li&gt;
&lt;li&gt;postMessage and Cross-Origin Resource Sharing (CORS): what is the difference
between these two?&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-the-motivating-web-applications-explained-in-the-paper&#34;&gt;What are the motivating web applications explained in the paper?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Password strength checker:

&lt;ul&gt;
&lt;li&gt;What are the possible security risks here?&lt;/li&gt;
&lt;li&gt;How does COWL add security to a third-party password checker?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Encrypted document editor&lt;/li&gt;
&lt;li&gt;Third-party mashup&lt;/li&gt;
&lt;li&gt;Untrusted third-party library: How does COWL mitigate reuse risks?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cowl-confinement-system&#34;&gt;COWL Confinement System&lt;/h2&gt;

&lt;h4 id=&#34;cowl-augments-browsers-with-three-primitives-what-are-these&#34;&gt;COWL augments browsers with three primitives. What are these?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Labeled browsing contexts&lt;/li&gt;
&lt;li&gt;Labeled communication&lt;/li&gt;
&lt;li&gt;Privileges&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;structure-of-a-label&#34;&gt;Structure of a label&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;(secrecy formula, integrity formula)

&lt;ul&gt;
&lt;li&gt;Secrecy: which origins can read a context’s data&lt;/li&gt;
&lt;li&gt;Integrity: which origins can write it&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-does-cowl-enforce-label-policies&#34;&gt;How does COWL enforce label policies?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Allowing a context to only communicate with other contexts or servers whose
labels are at least as restricting&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;can-a-script-leak-information-through-a-newly-created-context-how&#34;&gt;Can a script leak information through a newly created context? How?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Newly created context implicitly inherits current label of parent&lt;/li&gt;
&lt;li&gt;The parent may specify a more restrictive label for its child&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-the-two-types-of-contexts-cowl-applications-can-create&#34;&gt;What are the two types of contexts COWL applications can create?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Standard contexts: pages, iframes, workers, etc.&lt;/li&gt;
&lt;li&gt;Labeled contexts in the form of lightweight labeled workers (LWorkers)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-lworkers-and-why-are-they-helpful-why-not-use-normal-workers&#34;&gt;What are LWorkers and why are they helpful? Why not use normal workers?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Lightweight labeled workers which execute in the same thread as their parent&lt;/li&gt;
&lt;li&gt;Share the event loop with their parent&lt;/li&gt;
&lt;li&gt;Have access to COWL API, XHR constructor and can communicate with parent&lt;/li&gt;
&lt;li&gt;Parent can give read/write DOM access to child since they are in the same
thread&lt;/li&gt;
&lt;li&gt;LWorkers simplify the isolation and confinement of scripts&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-does-cowl-support-labeled-communication&#34;&gt;How does COWL support labeled communication?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Labeled Blob messages (intra-browser)&lt;/li&gt;
&lt;li&gt;Labeled XHR messages (browser-server)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-labeled-blobs&#34;&gt;What are labeled Blobs?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Encapsulation of an inter-context message (payload - serializable and
immutable Blob object) with the label&lt;/li&gt;
&lt;li&gt;This label is at least as restrictive as the sending context’s current label&lt;/li&gt;
&lt;li&gt;Receiving context can access label - and can access the message only after
it’s label is raised as needed&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;why-are-labeled-blobs-useful&#34;&gt;Why are labeled Blobs useful?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Sender can impose confinement on the receiver by labeling a message&lt;/li&gt;
&lt;li&gt;Receiver can delay reading the message content until they are done
communicating with origins not allowed to read the data&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-labeled-xhr-messages&#34;&gt;What are labeled XHR messages?&lt;/h4&gt;

&lt;p&gt;Similar to labeled Blobs but for browser-server communication&lt;/p&gt;

&lt;h4 id=&#34;when-may-a-context-need-to-declassify-data&#34;&gt;When may a context need to declassify data?&lt;/h4&gt;

&lt;p&gt;It may need to send encrypted data from one origin to a third-party origin&lt;/p&gt;

&lt;h4 id=&#34;how-does-cowl-s-privilege-primitive-support-declassification&#34;&gt;How does COWL’s Privilege primitive support declassification?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;A context may hold one or more privileges, each with respect to some origin.&lt;/li&gt;
&lt;li&gt;Possession of a privilege for an origin by a context denotes trust that the
scripts that execute within that context will not compromise the secrecy of
data from that origin&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;applications&#34;&gt;Applications&lt;/h2&gt;

&lt;h4 id=&#34;password-checker-similar-to-encrypted-document-editor-application&#34;&gt;Password checker similar to encrypted document editor application&lt;/h4&gt;

&lt;h4 id=&#34;how-does-the-encrypted-document-editor-open-and-save-an-encrypted-doc&#34;&gt;How does the encrypted document editor open and save an encrypted doc?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;gdoc.com downloads encrypted doc from Google’s servers&lt;/li&gt;
&lt;li&gt;gdoc.com opens an iframe to eff.org with label public and downloaded private
key&lt;/li&gt;
&lt;li&gt;gdoc.com sends the encrypted doc as labeled Blob with label (gdoc.com)&lt;/li&gt;
&lt;li&gt;The iframe unlabels the Blob and raises its label to decrypt the doc&lt;/li&gt;
&lt;li&gt;Pass the decrypted doc to the iframe implementing the editor&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;Reverse for saving a doc&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-does-cowl-support-third-party-mashups&#34;&gt;How does COWL support third-party mashups?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Mashup sends labeled XHRs to both Amazon and Chase to get purchase history
and bank statement as labeled Blobs&lt;/li&gt;
&lt;li&gt;Once all the info is received, mashup unlabels the responses and raises it’s
label COWL cannot prevent a malicious mashup from leaking data via covert
channels&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;how-does-cowl-confine-an-untrusted-jquery-library&#34;&gt;How does COWL confine an untrusted jQuery library?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;page generates a fresh origin unq0 and spawns a DOM worker&lt;/li&gt;
&lt;li&gt;main context drops its privileges and raises its label to (unq0)&lt;/li&gt;
&lt;li&gt;the trusted worker downloads jQuery&lt;/li&gt;
&lt;li&gt;The trusted worker injects the script content into the main context’s DOM&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The main context becomes untrusted, but is fully confined. The spawned DOM
worker can modify the DOM of the main context and communicate on the web -
acting as a firewall.&lt;/p&gt;

&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;

&lt;h3 id=&#34;what-are-the-challenges-to-implementing-cowl-for-chromium&#34;&gt;What are the challenges to implementing COWL for Chromium?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Chromium architecture does not have cross-compartment wrappers so the DOM
binding code was modified to insert label checks&lt;/li&gt;
&lt;li&gt;Without wrappers, shared references cannot be efficiently revoked&lt;/li&gt;
&lt;li&gt;The current Chromium API allows senders to disallow labeling Blobs if any
children were created before starting confinement mode&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;evaluation&#34;&gt;Evaluation&lt;/h2&gt;

&lt;h4 id=&#34;what-is-the-evaluation-strategy-used&#34;&gt;What is the evaluation strategy used?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Measuring cost of new primitives and impact on legacy websites that don’t use
COWL&lt;/li&gt;
&lt;li&gt;Benchmarks:

&lt;ul&gt;
&lt;li&gt;Microbenchmarks of API functions&lt;/li&gt;
&lt;li&gt;End-to-end benchmarks of example applications&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Applications accessed from a Node server over loopback&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-do-you-think-about-cowl-s-performance-for-microbenchmarks-and-end-to-end-benchmarks&#34;&gt;What do you think about COWL’s performance for microbenchmarks and end-to-end benchmarks?&lt;/h4&gt;

&lt;h2 id=&#34;discussion&#34;&gt;Discussion&lt;/h2&gt;

&lt;h4 id=&#34;what-are-the-benefits-and-risks-of-having-users-override-cors&#34;&gt;What are the benefits and risks of having users override CORS?&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>Chrome extension system</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/chrome-extension-system/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0708</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/chrome-extension-system/</guid>
      <description>

&lt;p&gt;Author: Ariana Mirian&lt;/p&gt;

&lt;h4 id=&#34;background&#34;&gt;Background&lt;/h4&gt;

&lt;p&gt;Presented in 2010, at NDSS (Network and Distributed System Security).&lt;/p&gt;

&lt;p&gt;The following people were on the paper:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Adam Barth: (one of first people working on) Security at Chrome&lt;/li&gt;
&lt;li&gt;Adrienne Porter Felt: Usable Security at Chrome&lt;/li&gt;
&lt;li&gt;Prateek Saxena: Prof at National University of Singapore&lt;/li&gt;
&lt;li&gt;Aaron Boodman: Helped build Chrome, now at Startup&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;They were all at some point invested in Google (or still are), and had a vested
interest in making a system that worked and was effective.&lt;/p&gt;

&lt;p&gt;To review, a browser extension is a third party software that extends the
functionality of a web browser.&lt;/p&gt;

&lt;h4 id=&#34;problem&#34;&gt;Problem&lt;/h4&gt;

&lt;p&gt;The question that the authors were trying to answer is if browser extensions
require such a high level of privilege.&lt;/p&gt;

&lt;p&gt;In order to answer this, the authors analyzed Firefox Browser system and
implement an alternate extension system with the Chrome Extension System.&lt;/p&gt;

&lt;p&gt;One could say that the Firefox model at the time was silly and had lacked any
regard for security. However, it is important to remember that extensions were
meant to supplement a user&amp;rsquo;s experience and, before this point, the use case
for extensions wasn&amp;rsquo;t clear. Firefox had no idea what to expect, while the
authors of this paper benefited from hindsight.&lt;/p&gt;

&lt;p&gt;The threat model is &lt;em&gt;benign but buggy&lt;/em&gt; extensions: a malicious attacker could
corrupt the extension and usurp its privileges.&lt;/p&gt;

&lt;h4 id=&#34;evolution-of-firefox&#34;&gt;Evolution of Firefox&lt;/h4&gt;

&lt;p&gt;The paper argues that the underlying issue of the four potential (out of many)
attacks is that Firefox extensions interact directly with untrusted content
while possessing a high level of privilege &amp;mdash; by rethinking the architecture
they aren&amp;rsquo;t just fixing one problem, they are addressing most of them.&lt;/p&gt;

&lt;p&gt;While they argue that there was no way to automate the extension analysis, there
might have been a way to perform a program analysis to look at how the APIs are
used. On this note, while their paper did well with only 25 extensions from the
Firefox Extension system, it could have benefited from a larger analysis to
provide a better picture of how the average extension dealt with privileges.&lt;/p&gt;

&lt;p&gt;Out of the 25 extensions that they analyzed, 19 had &amp;lsquo;critical&amp;rsquo; privileges,
meaning that they could run arbitrary code on the user&amp;rsquo;s system, while only 3
required critical privileges. This is an example of a privilege gap.&lt;/p&gt;

&lt;p&gt;The paper then goes into discussing a security lattice that they used to
analyze the Firefox extension API. They show that there is a considerable
number of escalation points that need to be addressed, and that the separation
of privileges is not necessarily as easy as it seems. APIs need to be designed
from the start with privileges in mind.&lt;/p&gt;

&lt;p&gt;From this analysis, they propose building a new system following the principle
of least privilege, privilege separation, and strong isolation.&lt;/p&gt;

&lt;h4 id=&#34;google-chrome-extension-system&#34;&gt;Google Chrome Extension System&lt;/h4&gt;

&lt;p&gt;The Google chrome extension system implements privilege separation and isolation
mechanisms.&lt;/p&gt;

&lt;h5 id=&#34;why-did-they-need-both&#34;&gt;Why did they need both?&lt;/h5&gt;

&lt;p&gt;The privilege separation was broken into three differed hierarchies: &lt;em&gt;content
scripts&lt;/em&gt;, &lt;em&gt;extension core&lt;/em&gt;, and &lt;em&gt;native binary&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Content scripts are JavaScript scripts that allow extensions to directly
interact with the untrusted web content (DOM) &amp;mdash; since they have the largest
attack surface, they do not have any direct access to privileged APIs. They can
only communicate with the extension core via message passing.&lt;/p&gt;

&lt;p&gt;Extension cores have access to privileged APIs (which, for example, allow them
to create new tabs) as declared in the extension&amp;rsquo;s manifest and approved by the
user at install time.  The core does not interact with untrusted web content
directly; it can only communicate with untrusted context via the content script
or using an XMLHTTPRequest.&lt;/p&gt;

&lt;p&gt;Finally, the native binary can run arbitrary code or access arbitrary files.&lt;/p&gt;

&lt;p&gt;The isolation mechanisms are similarly split up into separate parts.
- Origins are used to ensure isolation between different extension cores. This,
  for example, ensures that one extension cannot mess with another&amp;rsquo;s
  &lt;code&gt;localStorage&lt;/code&gt;.
- Extension cores and native binaries are run in different OS processes. This
  ensures isolation between themselves and content.
- Content scripts run in &lt;em&gt;isolated worlds&lt;/em&gt;. They have a separate JavaScript
  heap and separate access to the DOM of the untrusted web page they run in.
  This ensures that content scripts are isolated from the untrusted content and
  other extensions (under the buggy but benign model).&lt;/p&gt;

&lt;h4 id=&#34;discussion&#34;&gt;Discussion&lt;/h4&gt;

&lt;p&gt;In order to evaluate their system, they measured page latency and DOM access
time &amp;mdash; both had increases, respectively 0.8ms and 33.3%. What was missing was
a lack of a user study to understand the implications of their system. In the
end, the hindsight from the Firefox extension system helped them a lot, because
they were able to see a (small) sample of how users use extensions and what
could go wrong.&lt;/p&gt;

&lt;p&gt;Today, the paper could be improved in various ways. You could look at more
extensions or determine more concretely what the APIs should look like, and,
given yet more hindsight, consider a more realistic attacker model.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NaCl</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/nacl/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0706</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/nacl/</guid>
      <description>

&lt;p&gt;Author: Shravan Narayan&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-high-level-goal&#34;&gt;What is the high level goal?&lt;/h4&gt;

&lt;p&gt;To be able to run native binaries securely, while incurring as little overhead
as possible to ensure the safety of the system.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-high-level-strategy&#34;&gt;What is the high level strategy?&lt;/h4&gt;

&lt;p&gt;This is done by ensuring that any faults or bug are isolated to the module, i.e.
the bug cannot be used to take over the entire system.&lt;/p&gt;

&lt;h4 id=&#34;why-do-you-want-native-code&#34;&gt;Why do you want native code?&lt;/h4&gt;

&lt;p&gt;Native code has the benefit of running on bare metal, i.e. there are no layers
of interpreters or virtual machines that are needed for them to operate. Thus
the performance of native code is significantly better than interpreted code of
virtual machine code.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-threat-model&#34;&gt;What is the threat model?&lt;/h4&gt;

&lt;p&gt;The threat model is one of where a malicious website creator may use native
binaries to take over your computer, or a malicious entity could try to take
over the computer by abusing a bug in one of the native binaries that are
currently loaded on to the browser by a website.&lt;/p&gt;

&lt;h4 id=&#34;what-are-the-inner-and-outer-sandboxes&#34;&gt;What are the inner and outer sandboxes?&lt;/h4&gt;

&lt;p&gt;NaCl implements its security by running native binaries on 2 layers of
sandboxes. The inner layer is a sandbox that implements fault isolation - i.e.
any bug in the program is isolated such that it cannot have an effect on the
rest on the system. The outer sandbox is an added safety mechanism - this is a
layer that restricts system calls to only a subset of allowed ones.  In the
Linux Chromium version, this is currently implemented via
&lt;a href=&#34;https://en.wikipedia.org/wiki/Seccomp&#34;&gt;seccomp-bpf&lt;/a&gt; which allow this sort of
system call filtering.&lt;/p&gt;

&lt;h4 id=&#34;how-is-the-software-isolation-enforced-in-the-inner-sandbox-in-nacl&#34;&gt;How is the software isolation enforced in the inner sandbox in NaCl?&lt;/h4&gt;

&lt;p&gt;Software isolation is enforced with the help of the x86 memory segmentation
features and an instruction verifier.  Segments ensure that the program cannot
read/write to parts of memory outside the untrusted code&amp;rsquo;s bounds. The
instruction verifier ensures that only safe (e.g., no memory jumps),
properly-aligned instructions are allowed. Bit masks are used to ensure that
jump instructions cannot jump to the middle of existing instructions.&lt;/p&gt;

&lt;h4 id=&#34;what-are-some-of-the-complications-with-parsing-x86-code-what-steps-are-taken-to-mitigate-these-complications&#34;&gt;What are some of the complications with parsing x86 code? What steps are taken to mitigate these complications?&lt;/h4&gt;

&lt;p&gt;x86 code has variable sized instructions. Even a particular instruction may
have representations in multiple lengths. This may be lead to non-aligned
overlapping instructions. Another challenge is self modifying code - which is
used in applications such as JIT code generation etc.&lt;/p&gt;

&lt;p&gt;To reduce the complexity, all instructions are aligned at word boundaries (aka
32 bit aligned), self modifying code is not allowed and all jump instructions
are forced to jump to word boundaries.&lt;/p&gt;

&lt;h4 id=&#34;what-are-examples-of-instructions-or-other-operations-not-allowed-by-nacl&#34;&gt;What are examples of instructions or other operations not allowed by NaCl?&lt;/h4&gt;

&lt;p&gt;NaCl blocks any instructions that allow changing the segment state, system
calls, interrupts and return aka long jump instructions (a modified long jump
called NaCl jump which is an and instruction followed jump is allowed. The and
instruction ensures that the jump instruction stays at word boundaries.)&lt;/p&gt;

&lt;h4 id=&#34;what-happens-if-we-don-t-mask-jumps-i-e-what-happens-if-we-allow-regular-jump-or-return-instructions-instead-of-nacl-jump&#34;&gt;What happens if we don&amp;rsquo;t mask jumps, i.e. what happens if we allow regular jump or return instructions instead of NaCl jump?&lt;/h4&gt;

&lt;p&gt;If we don&amp;rsquo;t mask jumps, a program vulnerability could allow the execution of
instructions that are not allowed such as segment instructions, by creatively
jumping in the middle of an existing instruction. If the location for the jump
is picked carefully, the middle of a target instruction could be read by the
processor as an instruction which we want to block.&lt;/p&gt;

&lt;h4 id=&#34;what-happens-if-we-don-t-use-segmented-memory&#34;&gt;What happens if we don&amp;rsquo;t use segmented memory?&lt;/h4&gt;

&lt;p&gt;Without segmented memory, there is nothing stopping a jump instruction to jump
to an arbitrary location outside the segment (e.g., to parts of the trusted
reference monitor). Thus we would need some other mechanism to enforce the
program memory isolation. One such technique is used in one of the papers
referred to in the NaCl paper - PittsField. The PittsField paper enforces this
isolation without segments by applying a bit mask on the most significant bits
before every jump to ensure the jump is confined to a part of the memory.&lt;/p&gt;

&lt;h4 id=&#34;what-are-the-various-components-included-in-a-nacl-applications-runtime&#34;&gt;What are the various components included in a NaCl applications runtime?&lt;/h4&gt;

&lt;p&gt;Each sandboxed application is run in an environment with the following pieces
- an inter module communications service: which allows communication between
  components, components and the browser via messages, shared memory segments
  and synchronization objects
- service runtime: which allows memory management APIs, thread creation interfaces etc.&lt;/p&gt;

&lt;h4 id=&#34;why-does-nacl-have-srpc-and-npapi&#34;&gt;Why does NaCl have SRPC and NPAPI?&lt;/h4&gt;

&lt;p&gt;SRPC is a protocol that allows communication between NaCl modules as well as
the JavaScript in the browser by declaring the procedural interface with basic
data types. NPAPI (Netscape Plugin API) is a protocol which is used to interact
with DOM, JS objects directly, etc. NPAPI is actually quite an old protocol
that is no longer used by NaCl. They have replaced this with a new protocol
called Pepper with the goal of better platform portability and security.&lt;/p&gt;

&lt;h4 id=&#34;how-is-the-isolation-provided-by-nacl-thwart-a-simple-buffer-overflow-vulnerability-that-gives-arbitrary-code-execution&#34;&gt;How is the isolation provided by NaCl thwart a simple buffer overflow vulnerability that gives arbitrary code execution?&lt;/h4&gt;

&lt;p&gt;NaCl does not prevent the buffer overflow, however, the buffer is stored in a
separate data segment. So, a buffer overflow cannot be used to overwrite the
return pointer on the stack. Also, this segment is separated from the rest of
the call stack and the memory page containing the data segment is marked as
no-execute and so cannot be executed.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-validator-what-are-the-use-cases-and-constraints&#34;&gt;What is the validator? What are the use cases and constraints?&lt;/h4&gt;

&lt;p&gt;The validator is a program that is used prior to loading a NaCl binary. This
program validates that a given NaCl binary confirms to all the rules about
using only allowed and word aligned instructions, masking jump locations, etc.
The validator thus needs to be able to efficiently parse x86 instructions - the
word alignment restriction as well as a small subset of allowed instructions
makes this simpler. As the validator is used just before loading the binary, it
is required that this operate with minimum overhead, so as to not introduce any
latency.&lt;/p&gt;

&lt;h4 id=&#34;the-paper-talks-about-exceptions-what-are-they-how-are-they-supported&#34;&gt;The paper talks about exceptions. What are they? How are they supported?&lt;/h4&gt;

&lt;p&gt;There are 2 types of exceptions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hardware exceptions: interrupts delivered by the OS such as floating point exceptions&lt;/li&gt;
&lt;li&gt;Software exceptions: the regular exceptions encountered by the language which
are handled by the try catch syntax.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hardware exceptions are not supported and will cause the NaCl program to be
terminated. This is because segmented memory modes were not very well supported
by the OS - i.e. the OS doesn&amp;rsquo;t have a mechanism to deliver exceptions to
processed which have modified the stack segment register.  Software exceptions
function as expected.&lt;/p&gt;

&lt;h4 id=&#34;are-system-calls-allowed-in-nacl-describe-the-mechanism-used-to-enable-block-this&#34;&gt;Are system calls allowed in NaCl? Describe the mechanism used to enable/block this?&lt;/h4&gt;

&lt;p&gt;System calls are not directly allowed. However NaCl provides a mediated
approach to some functions, including system calls, with the help of trampolines
and springboards. These mechanisms are implemented as part of the Service
Runtime. Trampolines are trusted code that removes the segment restrictions,
and calls into unsandboxed code. This code executes and returns via the
springboard. The springboard resets these stack restrictions. Note that the
springboard code is also used as to provide the threading interface for a NaCl
binary - however this cannot be invoked directly by the sanboxed NaCl app.&lt;/p&gt;

&lt;h4 id=&#34;the-paper-describes-a-particular-memory-layout-for-nacl-binaries-what-are-the-benefits&#34;&gt;The paper describes a particular memory layout for NaCl binaries? What are the benefits?&lt;/h4&gt;

&lt;p&gt;The memory layout starts with one page (4kb) of unallocated space - this is
used to detect null pointer exceptions as any reference to this memory will
cause a page fault. The next 60 KB is used by the service runtime to load the
trusted trampoline and springboard code. Trampolines can only contain function
whose entries are at word boundaries as they need to be callable by the NaCl
binary. The springboard should not be called directly by the NaCl binary as it
manipulates segment information and so have entries that are not word aligned.&lt;/p&gt;

&lt;h4 id=&#34;what-were-some-of-the-modifications-required-to-the-compilers-to-generate-nacl-binaries&#34;&gt;What were some of the modifications required to the compilers to generate NaCl binaries?&lt;/h4&gt;

&lt;p&gt;GCC was modified to ensure&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;function entries were only at word boundaries&lt;/li&gt;
&lt;li&gt;branch targets are 32 bit aligned&lt;/li&gt;
&lt;li&gt;to use nacljump for indirect transfers&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-is-the-overhead-of-a-nacl-binary&#34;&gt;What is the overhead of a NaCl binary?&lt;/h4&gt;

&lt;p&gt;Several benchmarks were run to estimate overhead - the average overhead seems
to be about 5%. Benchmarks included SPEC2000, graphics tests, video decoding,
physics simulations, and games. The equally important metric was the latency
overhead of the NaCl verifier, which was measured to be on the order of
30MB/second (small compared to download time).&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>