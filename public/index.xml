<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CSE 291</title>
    <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/</link>
    <description>Recent content on CSE 291</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</managingEditor>
    <webMaster>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</webMaster>
    <lastBuildDate>Thu, 17 Nov 2016 01:37:21 -0702</lastBuildDate>
    <atom:link href="https://cseweb.ucsd.edu/~dstefan/cse291-fall16/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Ironclad Apps</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/ironclad-apps/</link>
      <pubDate>Thu, 17 Nov 2016 01:37:21 -0702</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/ironclad-apps/</guid>
      <description>

&lt;p&gt;Author: Fucheng Gao&lt;/p&gt;

&lt;h4 id=&#34;what-conference-did-this-paper-present-in&#34;&gt;What conference did this paper present in?&lt;/h4&gt;

&lt;p&gt;USENIX Symposium on Operating Systems Design and Implementation (OSDI)&lt;/p&gt;

&lt;h4 id=&#34;what-kind-of-need-is-satisfied-by-ironclad&#34;&gt;What kind of need is satisfied by Ironclad?&lt;/h4&gt;

&lt;p&gt;People want to assure their data secure when running apps in the could, without
trusting the cloud provider.&lt;/p&gt;

&lt;h4 id=&#34;what-s-the-shortcoming-of-previous-work-on-verification&#34;&gt;What&amp;rsquo;s the shortcoming of previous work on verification?&lt;/h4&gt;

&lt;p&gt;Currently software verification can provide strong guarantees, but the cost is
often high &amp;ndash; e.g., seL4 took over 20-person years.&lt;/p&gt;

&lt;h4 id=&#34;system-features&#34;&gt;System features&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;It can completely verify the software stack, which means it assume every part
of software is untrusted, e.g. OS, BIOS, etc.&lt;/li&gt;
&lt;li&gt;The verification is on low-level assembly, meaning some of the toolsets
(e.g., DafnyCC) need not not trusted.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;goals&#34;&gt;Goals&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Remote equivalence: A remote user should receive the same sequence
of messages as a user communicating with the app abstract state machine.&lt;/li&gt;
&lt;li&gt;Secure channel: Remote user can establish a secure channel to the app, in
the presence of an untrusted OS.&lt;/li&gt;
&lt;li&gt;Completeness: Every software component must be verified.&lt;/li&gt;
&lt;li&gt;Low level verification: verify the actual instruction to that are executed.&lt;/li&gt;
&lt;li&gt;Rapid development by systems programmers: Non-expert developers should be
able to rapidly develop a verified Ironclad app.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;non-goals&#34;&gt;Non-goals&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Compatibility&lt;/li&gt;
&lt;li&gt;Performance&lt;/li&gt;
&lt;li&gt;Covert-channels&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;main-techniques-used-by-ironclad&#34;&gt;Main techniques used by Ironclad&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Late launch: Run application in a protected environment&lt;/li&gt;
&lt;li&gt;Trusted computing: Tight software to a encryption key&lt;/li&gt;
&lt;li&gt;Software verification: Prove software action follows specification&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;threat-model&#34;&gt;Threat model&lt;/h4&gt;

&lt;p&gt;Provide security against software-based attackers, who may run arbitrary
software on machine before executing or after app executes. The adversary may
attack the BIOS, OS, etc.&lt;/p&gt;

&lt;p&gt;Ironclad only provides privacy and integrity; no liveness/DOS or consideration
for covert-channel attacks.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-tpm-trusted-platform-module-and-how-is-it-used-by-ironclad&#34;&gt;What is the TPM (Trusted Platform Module) and how is it used by Ironclad?&lt;/h4&gt;

&lt;p&gt;The TPM offers facilities for the secure generation of cryptographic keys,
random number generation, signing with the platform key, etc.&lt;/p&gt;

&lt;p&gt;The TPM is used by Ironclad to prove to the remote user that the app they think
is running is indeed that; i.e., the TPM is use for attestation. See
(TXT)[&lt;a href=&#34;https://en.wikipedia.org/wiki/Trusted_Execution_Technology&#34;&gt;https://en.wikipedia.org/wiki/Trusted_Execution_Technology&lt;/a&gt;] for modern usages.&lt;/p&gt;

&lt;h4 id=&#34;developer-workflow&#34;&gt;Developer workflow&lt;/h4&gt;

&lt;p&gt;Firsts, the developer write the high-level specification (trusted) and then
implements the app in Dafny (untrusted), using Hoare logic pre and post
conditions to make aid the verification. Using a specification translator, the
high-level spec will be translate to a BoogieX86 specification. The DafnyCC
complier will also compile the implementation into BoogieX86.  The verifier
will then verify if assembly code &amp;ldquo;matches&amp;rdquo; the spec. Finally, the trusted
assembler and linker produces the final binary.&lt;/p&gt;

&lt;h4 id=&#34;what-kind-of-specification-types-does-ironclad-rely-on&#34;&gt;What kind of specification types does Ironclad rely on?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Hardware specifications&lt;/li&gt;
&lt;li&gt;App Specifications&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-does-ironclad-simplify-hardware-specifications&#34;&gt;How does Ironclad simplify hardware specifications?&lt;/h4&gt;

&lt;p&gt;It only defines spec for the introductions it can reason about and uses in the
compilation stages; this is only slightly less than 60 instructions.&lt;/p&gt;

&lt;h4 id=&#34;how-does-ironclad-reduce-app-verification-cost&#34;&gt;How does Ironclad reduce app verification cost?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Preliminary verification: It performs a basic verification on Dafny code via
Z3. This lets developers quickly detect bugs when programming.&lt;/li&gt;
&lt;li&gt;Modular verification&lt;/li&gt;
&lt;li&gt;Shared verification&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;besides-functional-correctness-what-else-does-ironclad-prove&#34;&gt;Besides functional correctness what else does Ironclad prove?&lt;/h4&gt;

&lt;p&gt;They ensure privacy by proving noninterference. This is proved via Boogie&amp;rsquo;s
SymDiff.&lt;/p&gt;

&lt;h4 id=&#34;why-is-noninterference-not-usually-practical-for-real-apps&#34;&gt;Why is noninterference not usually practical for real apps?&lt;/h4&gt;

&lt;p&gt;Apps need to leak data. To this end, Ironclad introduced declassification via a
state machine.&lt;/p&gt;

&lt;h4 id=&#34;how-was-remote-equivalence-proved&#34;&gt;How was remote equivalence proved?&lt;/h4&gt;

&lt;p&gt;In short: they prove functional correctness for the declsssifier and noninterference for
the program up to the declassify statement and after it.&lt;/p&gt;

&lt;h4 id=&#34;what-feature-does-dafnycc-provide&#34;&gt;What feature does DafnyCC provide?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Type safety&lt;/li&gt;
&lt;li&gt;Array bound safety&lt;/li&gt;
&lt;li&gt;Transitive stack safety&lt;/li&gt;
&lt;li&gt;High-level property preservation&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-is-late-launch&#34;&gt;What is late-launch?&lt;/h4&gt;

&lt;p&gt;It resets the CPU to a known state, stores a measurement (hash) of the
in-memory code pointed to by the instruction’s argument, and jumps to that
code. After a late-launch, the hardware provides the program control of the CPU
and 64 KiB of protected memory.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Singularity</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/singularity/</link>
      <pubDate>Tue, 15 Nov 2016 01:37:21 -0703</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/singularity/</guid>
      <description>

&lt;p&gt;Author: Deian Stefan&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-motivation-behind-singularity-and-more-broadly-a-message-passing-os&#34;&gt;What is the motivation behind Singularity and, more broadly, a message passing OS?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Bugs/vulnerabilities in existing systems due to interaction between different
components. In the OS world, device drivers are plagued by vulnerabilities.&lt;/li&gt;
&lt;li&gt;Isolation between different components: bugs in one wont affect other&lt;/li&gt;
&lt;li&gt;In the real world, we want message passing for device drivers, browser
extensions, plugins, ets&lt;/li&gt;
&lt;li&gt;Low-level languages are prone to UAFs and memory leaks.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;They believe that these problems can be addressed by high-level languages and message passing.&lt;/p&gt;

&lt;p&gt;Shared messaging only &lt;em&gt;seems&lt;/em&gt; simple; in practice it gets complicated once you
need to worry about races. Locks and barriers are not easy to use.&lt;/p&gt;

&lt;h4 id=&#34;what-are-the-limitations-downsides-of-existing-message-passing-systems&#34;&gt;What are the limitations/downsides of existing message passing systems?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Complicated programming models&lt;/li&gt;
&lt;li&gt;Performance due to copying data&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-is-the-big-downside-of-high-level-languages&#34;&gt;What is the big downside of high-level languages?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;GC, and directly: performance&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;at-a-high-level-how-does-singularity-address-this&#34;&gt;At a high-level, how does Singularity address this?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;SIPs (software isolated processes) run in isolation from each other.

&lt;ul&gt;
&lt;li&gt;In general most things process handles are GCd.&lt;/li&gt;
&lt;li&gt;Can allocate data in the exchange heap to share with other processes. This
data is manually managed.&lt;/li&gt;
&lt;li&gt;No dynamically loaded code (can&amp;rsquo;t reason about ownership etc.)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Only communication between processes: channels.&lt;/li&gt;
&lt;li&gt;Can send scalars, channel end points and pointers on the exchange heap to
other SIPs.

&lt;ul&gt;
&lt;li&gt;Ownership model ensures memory safety.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;why-is-singularity-so-fast&#34;&gt;Why is Singularity so fast?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Context switching is cheap: no user-priv mode, no MMU to get in the way, all
isolation is done in software. Only marginally more expensive than a function
call.&lt;/li&gt;
&lt;li&gt;Message passing is cheap: no allocation, the 0-copy sends means only pointer
is sent and no data is copied. (Trade-off? programming model + flexibility)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-do-they-mean-when-they-say-memory-safety&#34;&gt;What do they mean when they say memory safety?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;No UAFs&lt;/li&gt;
&lt;li&gt;No memory leaks&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-do-they-address-this&#34;&gt;How do they address this?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Only one SIP can &lt;em&gt;own&lt;/em&gt; a block in the exchange heap.&lt;/li&gt;
&lt;li&gt;When you send pointer as message to another heap, they are now the owner of
this block. You can no longer use the pointer.&lt;/li&gt;
&lt;li&gt;They ensure this statically by tracking ownership at the language level:

&lt;ul&gt;
&lt;li&gt;You get ownership by allocating, as function parameter, or return value.&lt;/li&gt;
&lt;li&gt;You lose ownership when you call function or call delete.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Invariants: only 1 owner (UAF), owner must free (leak).&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-s-the-point-of-expose-and-what-can-go-wrong-without-it&#34;&gt;What&amp;rsquo;s the point of &lt;code&gt;expose&lt;/code&gt; and what can go wrong without it?&lt;/h4&gt;

&lt;p&gt;Transfer ownership of field from struct to function. Otherwise, we can have
issues like UAFs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void func(NetworkPacket* in ExHeap pk) {
  byte []  in ExHeap d = pkt-&amp;gt;data;
  f(pkt); // if f deletes pkt or if pkt-&amp;gt;data is deleted, etc. we crash below:
  d[32] = 44;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;why-does-singularity-have-channel-contracts-what-are-contracts-and-explain-2-issues-contracts-address-and-how-they-address-them&#34;&gt;Why does Singularity have channel contracts? What are contracts? And, explain 2 issues contracts address and how they address them.&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Homework question&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-is-the-role-of-the-tcell-t-constructor&#34;&gt;What is the role of the &lt;code&gt;TCell&amp;lt;T&amp;gt;&lt;/code&gt; constructor?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Homework question&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Singularity questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/singularity/</link>
      <pubDate>Tue, 15 Nov 2016 01:37:21 -0703</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/singularity/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Why does Singularity have channel contracts? What are contracts? And, explain 2 issues contracts address and how they address them.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What is the role of the &lt;code&gt;TCell&amp;lt;T&amp;gt;&lt;/code&gt; constructor? (That is, what problem was it designed to address?)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>S2E</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/s2e/</link>
      <pubDate>Mon, 14 Nov 2016 01:37:21 -0702</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/s2e/</guid>
      <description>

&lt;p&gt;Author: Brian Johannesmeyer&lt;/p&gt;

&lt;h4 id=&#34;what-conference-was-this-paper-in&#34;&gt;What conference was this paper in?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ASPLOS 2011, where it won best paper&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-types-of-analyses-can-a-developer-do-on-their-code&#34;&gt;What types of analyses can a developer do on their code?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Understand observed behavior&lt;/li&gt;
&lt;li&gt;Characterize future behavior

&lt;ul&gt;
&lt;li&gt;Should be able to do &amp;ldquo;what-if&amp;rdquo; analyses&lt;/li&gt;
&lt;li&gt;However this is difficult because systems are large and complex&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;what-three-properties-does-their-platform-offer&#34;&gt;What three properties does their platform offer?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Efficiently analyze &lt;em&gt;entire families of execution paths&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;i.e. More than one path of execution, and show that properties hold for all
paths in a system&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Maximize &lt;em&gt;realism&lt;/em&gt; by running the analyses in a real software stack

&lt;ul&gt;
&lt;li&gt;Take into account the whole environment surrounding a program&lt;/li&gt;
&lt;li&gt;Most approaches abstract away the environment behind a model, but that may
lose accuracy, and is also labor-intensive&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Ability to &lt;em&gt;directly analyze binaries&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;Access to source code is rarely feasible&lt;/li&gt;
&lt;li&gt;However, is this really a feature? Or are they &lt;em&gt;constrained&lt;/em&gt; to binaries?
This may not work on, e.g. direct JavaScript analysis.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;what-is-symbolic-execution&#34;&gt;What is symbolic execution?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Program analysis to determine what inputs cause each part of a program to execute&lt;/li&gt;
&lt;li&gt;Treat program as superposition of possible execution paths

&lt;ul&gt;
&lt;li&gt;e.g. &lt;code&gt;if(x&amp;gt;0) ... then ... else&lt;/code&gt; treated as superposition of two possible
paths: one for x&amp;gt;0 and one for x&amp;lt;=0.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;For some constraint (e.g. x&amp;gt;0), instead of allowing a variable to take on a
concrete value (e.g. x=5), it takes on a whole set of values (e.g. x:(0,+∞))&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-insight-makes-s2e-different-from-normal-symbolic-execution&#34;&gt;What insight makes S2E different from normal symbolic execution?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Often only some families of paths are of interest to developers (e.g. might
not care about analyzing kernel code)&lt;/li&gt;
&lt;li&gt;S2E can selectively choose what to symbolically execute by going back and
forth between multi-path mode (i.e. with symbolic values) and single-path
mode (i.e. with concrete values)&lt;/li&gt;
&lt;li&gt;Also, things can be thrown away in the analysis if we don&amp;rsquo;t care about it&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-are-symbolic-values-converted-to-concrete-values&#34;&gt;How are symbolic values converted to concrete values?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;By simply choosing a value from the symbolic set&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-are-concrete-values-converted-to-symbolic-values&#34;&gt;How are concrete values converted to symbolic values?&lt;/h4&gt;

&lt;p&gt;The symbolic value is constrained to whatever the concrete value was (e.g. x=5,
when originally x&amp;gt;0) to take into account any side effects x=4 may have had.
What can go wrong here?
- You lose a lot of information about the value later on when you convert back
  to a symbolic value, i.e. may overconstrain a value
- It affects completeness&lt;/p&gt;

&lt;h4 id=&#34;what-is-overconstraining&#34;&gt;What is overconstraining?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Constraining a value (whether by soft or hard constraints) so much that it
cannot go down future paths&lt;/li&gt;
&lt;li&gt;What is a soft constraint?

&lt;ul&gt;
&lt;li&gt;Constraint imposed by symbolic/concrete boundary (e.g. x:(0,+∞) -&amp;gt; x=5)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is a hard constraint?

&lt;ul&gt;
&lt;li&gt;Constraint imposed by code (e.g. x&amp;gt;0 in &lt;code&gt;if(x&amp;gt;0)...then...else&lt;/code&gt;)
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-is-the-process-of-converting-from-symbolic-to-concrete-values-and-back-processed&#34;&gt;How is the process of converting from symbolic to concrete values and back processed?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;According to an execution consistency model&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;let-s-define-the-parts-of-an-execution-consistency-model&#34;&gt;Let’s define the parts of an execution consistency model…&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Analysis spaces

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;System&lt;/strong&gt;: complete software system under analysis, including programs,
libraries, OS, etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unit&lt;/strong&gt;: the part of the system to be analyzed&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Environment&lt;/strong&gt;: the part of the system that’s not analyzed&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Path types (look at figure on top right of page 4)

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Statically feasible&lt;/strong&gt;: there exists a possible path in the system&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Locally feasible&lt;/strong&gt;: there exists a possible path in the system that’s
consistent with data-related constraints in the unit&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Globally feasible&lt;/strong&gt;: there exists a possible path in the system that’s
consistent with all data-related constraints (i.e. in both the unit and the
environment)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Metrics

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Complete&lt;/strong&gt;: every path through the unit that’s globally feasible will
eventually be discovered by exploration done on that unit&lt;/li&gt;
&lt;li&gt;i.e. all execution paths can be discovered&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consistent&lt;/strong&gt;: every path through the unit has a corresponding globally
feasible path through the system&lt;/li&gt;
&lt;li&gt;i.e. the unit can correctly run on the system&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Why do we care about completeness and consistency?

&lt;ul&gt;
&lt;li&gt;We can do different things with their tradeoffs (see table 1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;strict-consistency&#34;&gt;Strict consistency&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Based on globally feasibility

&lt;ul&gt;
&lt;li&gt;Admits only globally feasible paths, i.e. only allows paths that are
consistent with ALL data-related constraints&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is &lt;em&gt;Strictly Consistent Concrete Execution (SC-CE)&lt;/em&gt;?

&lt;ul&gt;
&lt;li&gt;System is a black box&lt;/li&gt;
&lt;li&gt;Only a single execution path; executed non-symbolically&lt;/li&gt;
&lt;li&gt;Used for:&lt;/li&gt;
&lt;li&gt;Units tests, fuzzing&lt;/li&gt;
&lt;li&gt;Valgrind&lt;/li&gt;
&lt;li&gt;Anything that executes along a single path, generated by user-specified
concrete inputs&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;Doesn&amp;rsquo;t symbolically track anything&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is &lt;em&gt;Strictly Consistent Unit-level Execution (SC-UE)&lt;/em&gt;?

&lt;ul&gt;
&lt;li&gt;Environment treated as a black box&lt;/li&gt;
&lt;li&gt;Exploration engine allowed to gather and use information internal to the unit&lt;/li&gt;
&lt;li&gt;Used by: symbolic and concolic execution tools&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;Symbolic value turned into concrete value when units calls environment&lt;/li&gt;
&lt;li&gt;When environment returns back to unit, the soft constraint it created
becomes a hard constraint&lt;/li&gt;
&lt;li&gt;This hinders completeness&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is &lt;em&gt;Strictly Consistent System-level Execution (SC-SE)&lt;/em&gt;?

&lt;ul&gt;
&lt;li&gt;Nothing is a black box&lt;/li&gt;
&lt;li&gt;Exploration engine allowed to gather and use information about the entire
system&lt;/li&gt;
&lt;li&gt;Limited by: path explosion problem&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;Symbolic values everywhere&lt;/li&gt;
&lt;li&gt;Path explosion

&lt;ul&gt;
&lt;li&gt;Can use heuristics to prioritize path exploration,&lt;/li&gt;
&lt;li&gt;Or employ incremental symbolic execution
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;local-consistency-lc&#34;&gt;Local Consistency (LC)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Avoids exploring all paths in the environment&lt;/li&gt;
&lt;li&gt;Replaces results of calls to the environment with the symbolic values that
represent possible valid results

&lt;ul&gt;
&lt;li&gt;e.g. &lt;code&gt;write(fd, buf,count)&lt;/code&gt; can return any integer between -1 and count&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Allows for inconsistencies in the environment while keeping the state of the
unit internally consistent&lt;/li&gt;
&lt;li&gt;No false positives because the internal state is consistent&lt;/li&gt;
&lt;li&gt;Implementation

&lt;ul&gt;
&lt;li&gt;At environment-boundary, concrete output value is turned into a symbolic
value based on the function’s specification&lt;/li&gt;
&lt;li&gt;However, if symbolic data is written to the environment, it may become
inconsistent&lt;/li&gt;
&lt;li&gt;If a branch in the environment depends on symbolic data, the execution
path must be aborted
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;relaxed-consistency&#34;&gt;Relaxed consistency&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Disadvantages

&lt;ul&gt;
&lt;li&gt;Inconsistent in the general case&lt;/li&gt;
&lt;li&gt;Internal state of the unit may be inconsistent, producing false positives&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Advantage: Performance&lt;/li&gt;
&lt;li&gt;What is &lt;em&gt;Overapproximate Consistency (RC-OC)&lt;/em&gt;?

&lt;ul&gt;
&lt;li&gt;Path exploration can follow paths through the unit while completely
ignoring the constraints&lt;/li&gt;
&lt;li&gt;E.g. call to write() would not bound the return value&lt;/li&gt;
&lt;li&gt;Thus, violates the specification of the write system call&lt;/li&gt;
&lt;li&gt;Used for: reverse engineering&lt;/li&gt;
&lt;li&gt;Why is it used for reverse engineering?&lt;/li&gt;
&lt;li&gt;See 6.1.2 - They fake the hardware in order to understand what the
drivers are doing&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;At unit/environment boundaries, converts concrete values into
unconstrained symbolic values&lt;/li&gt;
&lt;li&gt;E.g. All possible values that write() could return, rather values it
should return&lt;/li&gt;
&lt;li&gt;Gives completeness at the expense of consistency&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is &lt;em&gt;CFG Consistency (RC-CC)&lt;/em&gt;?

&lt;ul&gt;
&lt;li&gt;Exploration engine allowed to change any part of the system state as long
as the explored paths correspond to paths in the unit’s inter-procedural
CFG&lt;/li&gt;
&lt;li&gt;Used for: disassembling obfuscated and/or encrypted code&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;Pursues all outcomes of every branch, regardless of path constraints&lt;/li&gt;
&lt;li&gt;Thus, follows all edges in the unit&amp;rsquo;s inter-procedural CFG&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;s2e-api&#34;&gt;S2E API&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Tables 2 and 3 give the best overview of what core events can be used to
develop analysis tools, and an idea of the interface to the &lt;em&gt;ExecState&lt;/em&gt; object.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;How are bugs that may result from slower system execution in symbolic mode
mitigated?

&lt;ul&gt;
&lt;li&gt;The virtual clock is slowed down when symbolically executing a state&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Definitions

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Virtualization&lt;/strong&gt;: creating a software-based (or virtual) representation
of something rather than a physical one&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dynamic binary translation&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;Emulation of one instruction set by another through translation of binary
code (e.g. ARM -&amp;gt; x86)&lt;/li&gt;
&lt;li&gt;S2E turns blocks of guest code into corresponding host code&lt;/li&gt;
&lt;li&gt;Dynamic means it happens as it executes

&lt;ul&gt;
&lt;li&gt;Translates code as it is explored&lt;/li&gt;
&lt;li&gt;Typically one basic block is translated at a time then cached&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Copy-on-write&lt;/strong&gt;: improves performance by only copying an object when the
copy or the original is written to&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;evaluation&#34;&gt;Evaluation&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;What 3 questions did they try to answer and how did they go about evaluating them?

&lt;ol&gt;
&lt;li&gt;Is S2E a &lt;em&gt;general&lt;/em&gt; platform for building tools?&lt;/li&gt;
&lt;li&gt;Showed that S2E can be used to build 3 very different tools (section 6.1).&lt;/li&gt;
&lt;li&gt;Does S2E have reasonable &lt;em&gt;performance&lt;/em&gt;?&lt;/li&gt;
&lt;li&gt;Discussed its overhead in both concrete mode (~6x) and symbolic mode
(~78x) and ways to reduce it (section 6.2).&lt;/li&gt;
&lt;li&gt;What are the &lt;em&gt;tradeoffs&lt;/em&gt; between choosing different execution consistency
models?&lt;/li&gt;
&lt;li&gt;Gave figures showing code coverage, memory usage, and constraint solving
time based on which consistency model was used (section 6.3).&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;What is Table 4 trying to convey? Do it do so successfully?

&lt;ul&gt;
&lt;li&gt;It is trying to convey the usability of S2E: that it is straightforward to
instrument and create custom analysis tools. However there are a few things
that are wrong with their approach:&lt;/li&gt;
&lt;li&gt;First, they built DDT and RevNIC previously, so they already understand
the ins and outs of developing these types of analysis tools. Thus, their
development time should naturally be dramatically shorter because they&amp;rsquo;ve
already implemented a similar system. This confounds their development
time results.&lt;/li&gt;
&lt;li&gt;In addition, not many details are given for their calculation of
&amp;ldquo;person-hours&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Also, it mentions in Table 4&amp;rsquo;s caption that &amp;ldquo;10 KLOC of offline analysis
code is reused in [REV+]&amp;ldquo;. However, that element of the table does not
have those 10 KLOC added to it. If those 10 KLOC count against the
previous implementation (i.e. 57,000 LOC), it should count against the
new implementation too (i.e. 10,580 LOC instead of 580 LOC).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Even after going through the tradeoffs of different consistency models in
section 6.2, I don&amp;rsquo;t think it would be immediately clear to developers which
model they should use.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Microchex</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/uchex/</link>
      <pubDate>Mon, 07 Nov 2016 01:37:21 -0702</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/uchex/</guid>
      <description>

&lt;p&gt;Author: Gary Soeller&lt;/p&gt;

&lt;h4 id=&#34;what-problem-does-uchex-address&#34;&gt;What problem does uchex address?&lt;/h4&gt;

&lt;p&gt;Static bug checkers require a full compiler front end (lexer and parser) to build
a complete grammar. This often requires an enormous engineering effort and is
not easy for developers to write their own static checker.&lt;/p&gt;

&lt;h4 id=&#34;what-is-uchex&#34;&gt;What is uchex?&lt;/h4&gt;

&lt;p&gt;uchex is a framework for easily writing language agnostic static bug checkers.&lt;/p&gt;

&lt;h4 id=&#34;how-does-uchex-solve-the-problem-addressed&#34;&gt;How does uchex solve the problem addressed?&lt;/h4&gt;

&lt;p&gt;uchex solves the problem by using a &lt;em&gt;micro-grammar&lt;/em&gt;: a grammar which contains a
subset of the grammar being parsed. uchex allows developers to write a checker
for a subset of the grammar allowing them the ability to easily write a
checker.  A major benefit of uchex checkers is that they are language agnostic.
Furthermore, micro-grammars can also be language agnostic since they only parse
a small fraction of grammars. This allows code to be reused easily.&lt;/p&gt;

&lt;h4 id=&#34;what-are-the-properties-of-a-micro-grammar&#34;&gt;What are the properties of a micro-grammar?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;The original grammar is a subset of the micro-grammar.&lt;/li&gt;
&lt;li&gt;The original grammar and micro-grammar have the same structure.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Why are these two properties important?&lt;/p&gt;

&lt;h4 id=&#34;how-does-the-uchex-parser-differ-from-a-traditional-parser&#34;&gt;How does the uchex parser differ from a traditional parser?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Sliding window: This allows the parser to continue when it does not
recognize a token.&lt;/li&gt;
&lt;li&gt;Wildcard: Allows the parser to match anything.&lt;/li&gt;
&lt;li&gt;Commit points: Allows the parser to stop sliding forward once an important
token is reached for badly written micro-grammars.&lt;/li&gt;
&lt;li&gt;Compositional parsers: Allows parsers to be chained together. (Though
parsec-based parsers often have this property.)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;what-is-a-belief-style-checker&#34;&gt;What is a belief-style checker?&lt;/h4&gt;

&lt;p&gt;A type of checker that makes assumptions about the code. While traversing the
code, if the checker can contradict an assumption, then there is an error.&lt;/p&gt;

&lt;p&gt;All of the example checkers they present use belief-style, but they are not
necessarily limited to this.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-algorithm-for-the-null-pointer-checker&#34;&gt;What is the algorithm for the null pointer checker?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;When a pointer is dereferenced, it is added to a &amp;ldquo;not null&amp;rdquo; set. The &amp;ldquo;not
null&amp;rdquo; set is the set of &amp;ldquo;beliefs&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Whenever a not null check is made, the pointer is looked up in the &amp;ldquo;not
null&amp;rdquo; set.&lt;/li&gt;
&lt;li&gt;If pointer is set, a belief is contradicted indicating that there is an
error.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The null pointer checker uses forward data flow analysis. This allows the
checker to know information about the past. Other checkers use backward data
flow analysis which gives the checker information about the future.&lt;/p&gt;

&lt;h4 id=&#34;what-type-of-bugs-can-uchex-catch&#34;&gt;What type of bugs can uchex catch?&lt;/h4&gt;

&lt;p&gt;Intra-procedural. This is the most simple type of bug because it requires no
context outside of the function.&lt;/p&gt;

&lt;h4 id=&#34;what-types-of-bugs-does-uchex-not-catch&#34;&gt;What types of bugs does uchex not catch?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Those that require inter-procedural analysis.  What are inter procedural
checkers and what can these catch that uchex can&amp;rsquo;t?&lt;/li&gt;
&lt;li&gt;Those that require alias tracking. What is alias tracking and why is this
hard to support?&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;what-type-of-grammar-is-uchex-able-to-parse-and-why-is-this-important&#34;&gt;What type of grammar is uchex able to parse and why is this important?&lt;/h4&gt;

&lt;p&gt;uchex can parse LL(k) grammars. There are limitations with parsers so it is
important to know which type of parser is being used. One limitation of LL(k) is
that left-recursion can not be parsed. Therefore, the developer must eliminate
it from the grammar.&lt;/p&gt;

&lt;h4 id=&#34;how-is-uchex-evaluated&#34;&gt;How is uchex evaluated?&lt;/h4&gt;

&lt;p&gt;uchex is evaluated against an undisclosed industrial static checker (called
&lt;em&gt;SystemX&lt;/em&gt; in the paper). Both checkers are run on the same codebases and the
results are compared by counting the number and overlap of bugs found. It is
important to note that uchex and SystemX can use each others results as ground
truth. This way they can be used in conjunction to improve each other.&lt;/p&gt;

&lt;p&gt;uchex is also evaluated to demonstrate simplicity and ease of developing new
checkers. The only metric used is lines of code. This does not say much so it
should be taken with a grain of salt.&lt;/p&gt;

&lt;p&gt;Deian, on last point: if you&amp;rsquo;ve written checkers you&amp;rsquo;ll find that LOC is pretty
reasonable. Managing giant ASTs and state in existing frameworks is super hard.
Moreover, I think for this we can partially appeal to authority: Dawson has
done work on checkers for decades.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Microchex questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/uchex/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0709</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/uchex/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What are false negatives? Do they matter? How can you figure out a system&amp;rsquo;s
false negatives?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;#181;chex shows that by ignoring parts of a language we can write effective
checkers considerably more easily. Give another example or two of a domain
or problem where ignoring certain things (i.e., approximating) may lead to
more efficient but still effective solution.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>COWL questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/cowl/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0708</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/cowl/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Why are labeled blobs crucial for making COWL practical? (Can&amp;rsquo;t a context
just raise its label to ensure that a receiving context is at least as
sensitive before sending it data? Come up with a scenario where this
wouldn&amp;rsquo;t work.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why does COWL not allow arbitrary JavaScript objects to be labeled and sent
via &lt;code&gt;postMessage&lt;/code&gt;? (I.e., why must objects be &lt;em&gt;structurally clonable&lt;/em&gt;?)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;One can think of COWL as an adaptation of LIO for the browser. But, unlike
for LIO, we cannot prove termination-sensitive non-interference (TSNI) for
COWL. Recall what TSNI is and explain why we can&amp;rsquo;t prove this COWL.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Chrome extension system questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/chrome-extension-system/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0707</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/chrome-extension-system/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&amp;ldquo;Content scripts run in the same process as their associated web pages.&amp;rdquo;
What makes it difficult to run them in separate processes? Give 2 reasons.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Explain how a malicious extension that has the privilege to read/write
data on any origin can steal a user&amp;rsquo;s banking data even if they never visit
evil.com.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>NaCl questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/nacl/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0706</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/nacl/</guid>
      <description>&lt;p&gt;Answer any 3:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What the purpose of the inner sandbox? What guarantees does it provide and
how does NaCl implement it?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What the purpose of the outer sandbox? What guarantees does it provide and
how does NaCl implement it?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why did NaCl take the approach of statically verifying that a piece of x86
is safe instead of providing a trusted compiler approach?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why is it not possible to dynamically load a library with NaCl? What makes
this hard to do?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why does NaCl not support JITed language runtimes?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Verena questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/verena/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0705</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/verena/</guid>
      <description>&lt;p&gt;Answer any 2:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What is Verena&amp;rsquo;s attacker model? Don&amp;rsquo;t just rehash what&amp;rsquo;s in the paper.
Instead think about different stages (e.g., server was not compromised then
it was compromised, what can the attacker do?).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Describe the components that make up Verena&amp;rsquo;s architecture and their
individual roles.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What are &lt;em&gt;trust contexts&lt;/em&gt; and why are they necessary?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How do Verena&amp;rsquo;s integrity guarantees differ from Hails&amp;rsquo; integrity
guarantees?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Hails questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/hails/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0704</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/hails/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Does Hails suffer from the external timing channel? If so, explain the
attack. If not, explain why this is not a concern. Consider the scenario
where an attacker is able to execute code server-side (e.g., as part of a
VC).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hails relies on COWL to enforce IFC in the browser. Suppose that was not the
case. Can you think of a way of addressing leaks due to untrusted HTML using
a server-side only solution? (&lt;em&gt;Hint:&lt;/em&gt; you may want to look at the resin
assignment for inspiration.) Bonus: What about untrusted JavaScript?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why did Hails eventually move from policies as pure functions (&lt;code&gt;Document -&amp;gt;
Label&lt;/code&gt;) to side-effecting ones (&lt;code&gt;Document -&amp;gt; LIO Label&lt;/code&gt;)?  What is a
negative trade-offs due to this?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Resin questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/resin/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0704</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/resin/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;An alternative approach to hacking the runtime to implement Resin is to use
code rewriting, i.e., rewrite applications to perform the data flow tracking
inline. What are 2-3 challenges with this approach? (Hint: some language
features may make this more difficult than others.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What are some advantages and disadvantages to Resin&amp;rsquo;s policy specification
approach when compared to label based approaches like LIO?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>LIO questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/lio/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0702</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/lio/</guid>
      <description>&lt;p&gt;Please answer any 2 questions from the following list. We will discuss all of
them in class.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;LIO has a notion of clearance. Why? What is the purpose of clearance at a
high level?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How does LIO side-step the &lt;em&gt;implicit flows problem&lt;/em&gt;? What&amp;rsquo;s the downside to
the approach?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What is the difference between the termination channel, the internal timing
channel, and the external timing channel?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How can hardware features such as the cache be used to re-introduce the
internal timing channel?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;LIO only mitigates the external timing channel. Can you think of a way to
eliminate the channel? And what is the trade-off to your approach?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For some of these you may want to look at the journal version of the
&lt;a href=&#34;https://cseweb.ucsd.edu/~dstefan/pubs/stefan:2012:flexible.pdf&#34;&gt;sequential LIO
system&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JIF questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/jif/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0700</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/jif/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What is the key difference between IFC and discretionary access
control or capabilities?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What are the benefits of enforcing IFC statically? (Why doesn&amp;rsquo;t JIF take the
dynamic route?)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>COWL</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/cowl/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0709</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/cowl/</guid>
      <description>

&lt;p&gt;Author: Rohit Jha&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-motivation-behind-cowl&#34;&gt;What is the motivation behind COWL?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Flexibility vs privacy&lt;/li&gt;
&lt;li&gt;MAC-based confinement better than DAC&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;at-a-high-level-what-does-cowl-do&#34;&gt;At a high-level, what does COWL do?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;COWL is a robust JavaScript confinement system for modern web browsers.&lt;/li&gt;
&lt;li&gt;COWL introduces label-based MAC to browsing contexts (pages, iframes, etc.)
in a way that is fully backward-compatible with legacy web content&lt;/li&gt;
&lt;li&gt;Prevents information leaks&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-the-design-requirements-for-cowl&#34;&gt;What are the design requirements for COWL?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;MAC with:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Symmetric confinement: two mutually distrusting scripts can each confine
the other’s use of data they send one another&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hierarchical confinement: allows any developer to confine untrusted code,
and confinement can be nested to arbitrary depths&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Delegation: allows a developer explicitly to confer the privileges of one
execution context on a separate execution context&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;

&lt;h4 id=&#34;what-are-some-browser-security-policies-and-concepts-explained-in-the-paper&#34;&gt;What are some browser security policies and concepts explained in the paper?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Browsing contexts&lt;/li&gt;
&lt;li&gt;Same-Origin Policy (SOP): how does SOP not prevent data from being disclosed
to foreign origins?&lt;/li&gt;
&lt;li&gt;Content Security Policy (CSP): what are the limitations of CSP?&lt;/li&gt;
&lt;li&gt;postMessage and Cross-Origin Resource Sharing (CORS): what is the difference
between these two?&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-the-motivating-web-applications-explained-in-the-paper&#34;&gt;What are the motivating web applications explained in the paper?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Password strength checker:

&lt;ul&gt;
&lt;li&gt;What are the possible security risks here?&lt;/li&gt;
&lt;li&gt;How does COWL add security to a third-party password checker?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Encrypted document editor&lt;/li&gt;
&lt;li&gt;Third-party mashup&lt;/li&gt;
&lt;li&gt;Untrusted third-party library: How does COWL mitigate reuse risks?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cowl-confinement-system&#34;&gt;COWL Confinement System&lt;/h2&gt;

&lt;h4 id=&#34;cowl-augments-browsers-with-three-primitives-what-are-these&#34;&gt;COWL augments browsers with three primitives. What are these?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Labeled browsing contexts&lt;/li&gt;
&lt;li&gt;Labeled communication&lt;/li&gt;
&lt;li&gt;Privileges&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;structure-of-a-label&#34;&gt;Structure of a label&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;(secrecy formula, integrity formula)

&lt;ul&gt;
&lt;li&gt;Secrecy: which origins can read a context’s data&lt;/li&gt;
&lt;li&gt;Integrity: which origins can write it&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-does-cowl-enforce-label-policies&#34;&gt;How does COWL enforce label policies?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Allowing a context to only communicate with other contexts or servers whose
labels are at least as restricting&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;can-a-script-leak-information-through-a-newly-created-context-how&#34;&gt;Can a script leak information through a newly created context? How?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Newly created context implicitly inherits current label of parent&lt;/li&gt;
&lt;li&gt;The parent may specify a more restrictive label for its child&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-the-two-types-of-contexts-cowl-applications-can-create&#34;&gt;What are the two types of contexts COWL applications can create?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Standard contexts: pages, iframes, workers, etc.&lt;/li&gt;
&lt;li&gt;Labeled contexts in the form of lightweight labeled workers (LWorkers)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-lworkers-and-why-are-they-helpful-why-not-use-normal-workers&#34;&gt;What are LWorkers and why are they helpful? Why not use normal workers?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Lightweight labeled workers which execute in the same thread as their parent&lt;/li&gt;
&lt;li&gt;Share the event loop with their parent&lt;/li&gt;
&lt;li&gt;Have access to COWL API, XHR constructor and can communicate with parent&lt;/li&gt;
&lt;li&gt;Parent can give read/write DOM access to child since they are in the same
thread&lt;/li&gt;
&lt;li&gt;LWorkers simplify the isolation and confinement of scripts&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-does-cowl-support-labeled-communication&#34;&gt;How does COWL support labeled communication?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Labeled Blob messages (intra-browser)&lt;/li&gt;
&lt;li&gt;Labeled XHR messages (browser-server)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-labeled-blobs&#34;&gt;What are labeled Blobs?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Encapsulation of an inter-context message (payload - serializable and
immutable Blob object) with the label&lt;/li&gt;
&lt;li&gt;This label is at least as restrictive as the sending context’s current label&lt;/li&gt;
&lt;li&gt;Receiving context can access label - and can access the message only after
it’s label is raised as needed&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;why-are-labeled-blobs-useful&#34;&gt;Why are labeled Blobs useful?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Sender can impose confinement on the receiver by labeling a message&lt;/li&gt;
&lt;li&gt;Receiver can delay reading the message content until they are done
communicating with origins not allowed to read the data&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-labeled-xhr-messages&#34;&gt;What are labeled XHR messages?&lt;/h4&gt;

&lt;p&gt;Similar to labeled Blobs but for browser-server communication&lt;/p&gt;

&lt;h4 id=&#34;when-may-a-context-need-to-declassify-data&#34;&gt;When may a context need to declassify data?&lt;/h4&gt;

&lt;p&gt;It may need to send encrypted data from one origin to a third-party origin&lt;/p&gt;

&lt;h4 id=&#34;how-does-cowl-s-privilege-primitive-support-declassification&#34;&gt;How does COWL’s Privilege primitive support declassification?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;A context may hold one or more privileges, each with respect to some origin.&lt;/li&gt;
&lt;li&gt;Possession of a privilege for an origin by a context denotes trust that the
scripts that execute within that context will not compromise the secrecy of
data from that origin&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;applications&#34;&gt;Applications&lt;/h2&gt;

&lt;h4 id=&#34;password-checker-similar-to-encrypted-document-editor-application&#34;&gt;Password checker similar to encrypted document editor application&lt;/h4&gt;

&lt;h4 id=&#34;how-does-the-encrypted-document-editor-open-and-save-an-encrypted-doc&#34;&gt;How does the encrypted document editor open and save an encrypted doc?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;gdoc.com downloads encrypted doc from Google’s servers&lt;/li&gt;
&lt;li&gt;gdoc.com opens an iframe to eff.org with label public and downloaded private
key&lt;/li&gt;
&lt;li&gt;gdoc.com sends the encrypted doc as labeled Blob with label (gdoc.com)&lt;/li&gt;
&lt;li&gt;The iframe unlabels the Blob and raises its label to decrypt the doc&lt;/li&gt;
&lt;li&gt;Pass the decrypted doc to the iframe implementing the editor&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;Reverse for saving a doc&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-does-cowl-support-third-party-mashups&#34;&gt;How does COWL support third-party mashups?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Mashup sends labeled XHRs to both Amazon and Chase to get purchase history
and bank statement as labeled Blobs&lt;/li&gt;
&lt;li&gt;Once all the info is received, mashup unlabels the responses and raises it’s
label COWL cannot prevent a malicious mashup from leaking data via covert
channels&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;how-does-cowl-confine-an-untrusted-jquery-library&#34;&gt;How does COWL confine an untrusted jQuery library?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;page generates a fresh origin unq0 and spawns a DOM worker&lt;/li&gt;
&lt;li&gt;main context drops its privileges and raises its label to (unq0)&lt;/li&gt;
&lt;li&gt;the trusted worker downloads jQuery&lt;/li&gt;
&lt;li&gt;The trusted worker injects the script content into the main context’s DOM&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The main context becomes untrusted, but is fully confined. The spawned DOM
worker can modify the DOM of the main context and communicate on the web -
acting as a firewall.&lt;/p&gt;

&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;

&lt;h3 id=&#34;what-are-the-challenges-to-implementing-cowl-for-chromium&#34;&gt;What are the challenges to implementing COWL for Chromium?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Chromium architecture does not have cross-compartment wrappers so the DOM
binding code was modified to insert label checks&lt;/li&gt;
&lt;li&gt;Without wrappers, shared references cannot be efficiently revoked&lt;/li&gt;
&lt;li&gt;The current Chromium API allows senders to disallow labeling Blobs if any
children were created before starting confinement mode&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;evaluation&#34;&gt;Evaluation&lt;/h2&gt;

&lt;h4 id=&#34;what-is-the-evaluation-strategy-used&#34;&gt;What is the evaluation strategy used?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Measuring cost of new primitives and impact on legacy websites that don’t use
COWL&lt;/li&gt;
&lt;li&gt;Benchmarks:

&lt;ul&gt;
&lt;li&gt;Microbenchmarks of API functions&lt;/li&gt;
&lt;li&gt;End-to-end benchmarks of example applications&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Applications accessed from a Node server over loopback&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-do-you-think-about-cowl-s-performance-for-microbenchmarks-and-end-to-end-benchmarks&#34;&gt;What do you think about COWL’s performance for microbenchmarks and end-to-end benchmarks?&lt;/h4&gt;

&lt;h2 id=&#34;discussion&#34;&gt;Discussion&lt;/h2&gt;

&lt;h4 id=&#34;what-are-the-benefits-and-risks-of-having-users-override-cors&#34;&gt;What are the benefits and risks of having users override CORS?&lt;/h4&gt;
</description>
    </item>
    
  </channel>
</rss>