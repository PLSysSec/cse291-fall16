<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CSE 291</title>
    <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/</link>
    <description>Recent content on CSE 291</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</managingEditor>
    <webMaster>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</webMaster>
    <lastBuildDate>Wed, 28 Sep 2016 15:44:04 -0709</lastBuildDate>
    <atom:link href="https://cseweb.ucsd.edu/~dstefan/cse291-fall16/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Microchex questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/uchex/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0709</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/uchex/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What are false negatives? Do they matter? How can you figure out a system&amp;rsquo;s
false negatives?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;#181;chex shows that by ignoring parts of a language we can write effective
checkers considerably more easily. Give another example or two of a domain
or problem where ignoring certain things (i.e., approximating) may lead to
more efficient but still effective solution.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>COWL questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/cowl/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0708</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/cowl/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Why are labeled blobs crucial for making COWL practical? (Can&amp;rsquo;t a context
just raise its label to ensure that a receiving context is at least as
sensitive before sending it data? Come up with a scenario where this
wouldn&amp;rsquo;t work.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why does COWL not allow arbitrary JavaScript objects to be labeled and sent
via &lt;code&gt;postMessage&lt;/code&gt;? (I.e., why must objects be &lt;em&gt;structurally clonable&lt;/em&gt;?)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;One can think of COWL as an adaptation of LIO for the browser. But, unlike
for LIO, we cannot prove termination-sensitive non-interference (TSNI) for
COWL. Recall what TSNI is and explain why we can&amp;rsquo;t prove this COWL.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Chrome extension system questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/chrome-extension-system/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0707</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/chrome-extension-system/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&amp;ldquo;Content scripts run in the same process as their associated web pages.&amp;rdquo;
What makes it difficult to run them in separate processes? Give 2 reasons.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Explain how a malicious extension that has the privilege to read/write
data on any origin can steal a user&amp;rsquo;s banking data even if they never visit
evil.com.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>NaCl questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/nacl/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0706</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/nacl/</guid>
      <description>&lt;p&gt;Answer any 3:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What the purpose of the inner sandbox? What guarantees does it provide and
how does NaCl implement it?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What the purpose of the outer sandbox? What guarantees does it provide and
how does NaCl implement it?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why did NaCl take the approach of statically verifying that a piece of x86
is safe instead of providing a trusted compiler approach?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why is it not possible to dynamically load a library with NaCl? What makes
this hard to do?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why does NaCl not support JITed language runtimes?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Verena questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/verena/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0705</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/verena/</guid>
      <description>&lt;p&gt;Answer any 2:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What is Verena&amp;rsquo;s attacker model? Don&amp;rsquo;t just rehash what&amp;rsquo;s in the paper.
Instead think about different stages (e.g., server was not compromised then
it was compromised, what can the attacker do?).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Describe the components that make up Verena&amp;rsquo;s architecture and their
individual roles.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What are &lt;em&gt;trust contexts&lt;/em&gt; and why are they necessary?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How do Verena&amp;rsquo;s integrity guarantees differ from Hails&amp;rsquo; integrity
guarantees?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Hails questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/hails/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0704</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/hails/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Does Hails suffer from the external timing channel? If so, explain the
attack. If not, explain why this is not a concern. Consider the scenario
where an attacker is able to execute code server-side (e.g., as part of a
VC).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hails relies on COWL to enforce IFC in the browser. Suppose that was not the
case. Can you think of a way of addressing leaks due to untrusted HTML using
a server-side only solution? (&lt;em&gt;Hint:&lt;/em&gt; you may want to look at the resin
assignment for inspiration.) Bonus: What about untrusted JavaScript?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why did Hails eventually move from policies as pure functions (&lt;code&gt;Document -&amp;gt;
Label&lt;/code&gt;) to side-effecting ones (&lt;code&gt;Document -&amp;gt; LIO Label&lt;/code&gt;)?  What is a
negative trade-offs due to this?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Resin questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/resin/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0704</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/resin/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;An alternative approach to hacking the runtime to implement Resin is to use
code rewriting, i.e., rewrite applications to perform the data flow tracking
inline. What are 2-3 challenges with this approach? (Hint: some language
features may make this more difficult than others.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What are some advantages and disadvantages to Resin&amp;rsquo;s policy specification
approach when compared to label based approaches like LIO?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>LIO questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/lio/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0702</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/lio/</guid>
      <description>&lt;p&gt;Please answer any 2 questions from the following list. We will discuss all of
them in class.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;LIO has a notion of clearance. Why? What is the purpose of clearance at a
high level?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How does LIO side-step the &lt;em&gt;implicit flows problem&lt;/em&gt;? What&amp;rsquo;s the downside to
the approach?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What is the difference between the termination channel, the internal timing
channel, and the external timing channel?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How can hardware features such as the cache be used to re-introduce the
internal timing channel?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;LIO only mitigates the external timing channel. Can you think of a way to
eliminate the channel? And what is the trade-off to your approach?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For some of these you may want to look at the journal version of the
&lt;a href=&#34;https://cseweb.ucsd.edu/~dstefan/pubs/stefan:2012:flexible.pdf&#34;&gt;sequential LIO
system&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JIF questions</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/jif/</link>
      <pubDate>Wed, 28 Sep 2016 15:44:04 -0700</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/assignments/jif/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What is the key difference between IFC and discretionary access
control or capabilities?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What are the benefits of enforcing IFC statically? (Why doesn&amp;rsquo;t JIF take the
dynamic route?)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>COW</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/cowl/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0709</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/cowl/</guid>
      <description>

&lt;p&gt;Author: Rohit Jha&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-motivation-behind-cowl&#34;&gt;What is the motivation behind COWL?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Flexibility vs privacy&lt;/li&gt;
&lt;li&gt;MAC-based confinement better than DAC&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;at-a-high-level-what-does-cowl-do&#34;&gt;At a high-level, what does COWL do?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;COWL is a robust JavaScript confinement system for modern web browsers.&lt;/li&gt;
&lt;li&gt;COWL introduces label-based MAC to browsing contexts (pages, iframes, etc.)
in a way that is fully backward-compatible with legacy web content&lt;/li&gt;
&lt;li&gt;Prevents information leaks&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-the-design-requirements-for-cowl&#34;&gt;What are the design requirements for COWL?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;MAC with:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Symmetric confinement: two mutually distrusting scripts can each confine
the other’s use of data they send one another&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hierarchical confinement: allows any developer to confine untrusted code,
and confinement can be nested to arbitrary depths&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Delegation: allows a developer explicitly to confer the privileges of one
execution context on a separate execution context&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;

&lt;h4 id=&#34;what-are-some-browser-security-policies-and-concepts-explained-in-the-paper&#34;&gt;What are some browser security policies and concepts explained in the paper?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Browsing contexts&lt;/li&gt;
&lt;li&gt;Same-Origin Policy (SOP): how does SOP not prevent data from being disclosed
to foreign origins?&lt;/li&gt;
&lt;li&gt;Content Security Policy (CSP): what are the limitations of CSP?&lt;/li&gt;
&lt;li&gt;postMessage and Cross-Origin Resource Sharing (CORS): what is the difference
between these two?&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-the-motivating-web-applications-explained-in-the-paper&#34;&gt;What are the motivating web applications explained in the paper?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Password strength checker:

&lt;ul&gt;
&lt;li&gt;What are the possible security risks here?&lt;/li&gt;
&lt;li&gt;How does COWL add security to a third-party password checker?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Encrypted document editor&lt;/li&gt;
&lt;li&gt;Third-party mashup&lt;/li&gt;
&lt;li&gt;Untrusted third-party library: How does COWL mitigate reuse risks?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cowl-confinement-system&#34;&gt;COWL Confinement System&lt;/h2&gt;

&lt;h4 id=&#34;cowl-augments-browsers-with-three-primitives-what-are-these&#34;&gt;COWL augments browsers with three primitives. What are these?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Labeled browsing contexts&lt;/li&gt;
&lt;li&gt;Labeled communication&lt;/li&gt;
&lt;li&gt;Privileges&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;structure-of-a-label&#34;&gt;Structure of a label&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;(secrecy formula, integrity formula)

&lt;ul&gt;
&lt;li&gt;Secrecy: which origins can read a context’s data&lt;/li&gt;
&lt;li&gt;Integrity: which origins can write it&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-does-cowl-enforce-label-policies&#34;&gt;How does COWL enforce label policies?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Allowing a context to only communicate with other contexts or servers whose
labels are at least as restricting&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;can-a-script-leak-information-through-a-newly-created-context-how&#34;&gt;Can a script leak information through a newly created context? How?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Newly created context implicitly inherits current label of parent&lt;/li&gt;
&lt;li&gt;The parent may specify a more restrictive label for its child&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-the-two-types-of-contexts-cowl-applications-can-create&#34;&gt;What are the two types of contexts COWL applications can create?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Standard contexts: pages, iframes, workers, etc.&lt;/li&gt;
&lt;li&gt;Labeled contexts in the form of lightweight labeled workers (LWorkers)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-lworkers-and-why-are-they-helpful-why-not-use-normal-workers&#34;&gt;What are LWorkers and why are they helpful? Why not use normal workers?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Lightweight labeled workers which execute in the same thread as their parent&lt;/li&gt;
&lt;li&gt;Share the event loop with their parent&lt;/li&gt;
&lt;li&gt;Have access to COWL API, XHR constructor and can communicate with parent&lt;/li&gt;
&lt;li&gt;Parent can give read/write DOM access to child since they are in the same
thread&lt;/li&gt;
&lt;li&gt;LWorkers simplify the isolation and confinement of scripts&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-does-cowl-support-labeled-communication&#34;&gt;How does COWL support labeled communication?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Labeled Blob messages (intra-browser)&lt;/li&gt;
&lt;li&gt;Labeled XHR messages (browser-server)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-labeled-blobs&#34;&gt;What are labeled Blobs?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Encapsulation of an inter-context message (payload - serializable and
immutable Blob object) with the label&lt;/li&gt;
&lt;li&gt;This label is at least as restrictive as the sending context’s current label&lt;/li&gt;
&lt;li&gt;Receiving context can access label - and can access the message only after
it’s label is raised as needed&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;why-are-labeled-blobs-useful&#34;&gt;Why are labeled Blobs useful?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Sender can impose confinement on the receiver by labeling a message&lt;/li&gt;
&lt;li&gt;Receiver can delay reading the message content until they are done
communicating with origins not allowed to read the data&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-labeled-xhr-messages&#34;&gt;What are labeled XHR messages?&lt;/h4&gt;

&lt;p&gt;Similar to labeled Blobs but for browser-server communication&lt;/p&gt;

&lt;h4 id=&#34;when-may-a-context-need-to-declassify-data&#34;&gt;When may a context need to declassify data?&lt;/h4&gt;

&lt;p&gt;It may need to send encrypted data from one origin to a third-party origin&lt;/p&gt;

&lt;h4 id=&#34;how-does-cowl-s-privilege-primitive-support-declassification&#34;&gt;How does COWL’s Privilege primitive support declassification?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;A context may hold one or more privileges, each with respect to some origin.&lt;/li&gt;
&lt;li&gt;Possession of a privilege for an origin by a context denotes trust that the
scripts that execute within that context will not compromise the secrecy of
data from that origin&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;applications&#34;&gt;Applications&lt;/h2&gt;

&lt;h4 id=&#34;password-checker-similar-to-encrypted-document-editor-application&#34;&gt;Password checker similar to encrypted document editor application&lt;/h4&gt;

&lt;h4 id=&#34;how-does-the-encrypted-document-editor-open-and-save-an-encrypted-doc&#34;&gt;How does the encrypted document editor open and save an encrypted doc?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;gdoc.com downloads encrypted doc from Google’s servers&lt;/li&gt;
&lt;li&gt;gdoc.com opens an iframe to eff.org with label public and downloaded private
key&lt;/li&gt;
&lt;li&gt;gdoc.com sends the encrypted doc as labeled Blob with label (gdoc.com)&lt;/li&gt;
&lt;li&gt;The iframe unlabels the Blob and raises its label to decrypt the doc&lt;/li&gt;
&lt;li&gt;Pass the decrypted doc to the iframe implementing the editor&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;Reverse for saving a doc&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-does-cowl-support-third-party-mashups&#34;&gt;How does COWL support third-party mashups?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Mashup sends labeled XHRs to both Amazon and Chase to get purchase history
and bank statement as labeled Blobs&lt;/li&gt;
&lt;li&gt;Once all the info is received, mashup unlabels the responses and raises it’s
label COWL cannot prevent a malicious mashup from leaking data via covert
channels&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;how-does-cowl-confine-an-untrusted-jquery-library&#34;&gt;How does COWL confine an untrusted jQuery library?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;page generates a fresh origin unq0 and spawns a DOM worker&lt;/li&gt;
&lt;li&gt;main context drops its privileges and raises its label to (unq0)&lt;/li&gt;
&lt;li&gt;the trusted worker downloads jQuery&lt;/li&gt;
&lt;li&gt;The trusted worker injects the script content into the main context’s DOM&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The main context becomes untrusted, but is fully confined. The spawned DOM
worker can modify the DOM of the main context and communicate on the web -
acting as a firewall.&lt;/p&gt;

&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;

&lt;h3 id=&#34;what-are-the-challenges-to-implementing-cowl-for-chromium&#34;&gt;What are the challenges to implementing COWL for Chromium?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Chromium architecture does not have cross-compartment wrappers so the DOM
binding code was modified to insert label checks&lt;/li&gt;
&lt;li&gt;Without wrappers, shared references cannot be efficiently revoked&lt;/li&gt;
&lt;li&gt;The current Chromium API allows senders to disallow labeling Blobs if any
children were created before starting confinement mode&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;evaluation&#34;&gt;Evaluation&lt;/h2&gt;

&lt;h4 id=&#34;what-is-the-evaluation-strategy-used&#34;&gt;What is the evaluation strategy used?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Measuring cost of new primitives and impact on legacy websites that don’t use
COWL&lt;/li&gt;
&lt;li&gt;Benchmarks:

&lt;ul&gt;
&lt;li&gt;Microbenchmarks of API functions&lt;/li&gt;
&lt;li&gt;End-to-end benchmarks of example applications&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Applications accessed from a Node server over loopback&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-do-you-think-about-cowl-s-performance-for-microbenchmarks-and-end-to-end-benchmarks&#34;&gt;What do you think about COWL’s performance for microbenchmarks and end-to-end benchmarks?&lt;/h4&gt;

&lt;h2 id=&#34;discussion&#34;&gt;Discussion&lt;/h2&gt;

&lt;h4 id=&#34;what-are-the-benefits-and-risks-of-having-users-override-cors&#34;&gt;What are the benefits and risks of having users override CORS?&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>Chrome extension system</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/chrome-extension-system/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0708</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/chrome-extension-system/</guid>
      <description>

&lt;p&gt;Author: Ariana Mirian&lt;/p&gt;

&lt;h4 id=&#34;background&#34;&gt;Background&lt;/h4&gt;

&lt;p&gt;Presented in 2010, at NDSS (Network and Distributed System Security).&lt;/p&gt;

&lt;p&gt;The following people were on the paper:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Adam Barth: (one of first people working on) Security at Chrome&lt;/li&gt;
&lt;li&gt;Adrienne Porter Felt: Usable Security at Chrome&lt;/li&gt;
&lt;li&gt;Prateek Saxena: Prof at National University of Singapore&lt;/li&gt;
&lt;li&gt;Aaron Boodman: Helped build Chrome, now at Startup&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;They were all at some point invested in Google (or still are), and had a vested
interest in making a system that worked and was effective.&lt;/p&gt;

&lt;p&gt;To review, a browser extension is a third party software that extends the
functionality of a web browser.&lt;/p&gt;

&lt;h4 id=&#34;problem&#34;&gt;Problem&lt;/h4&gt;

&lt;p&gt;The question that the authors were trying to answer is if browser extensions
require such a high level of privilege.&lt;/p&gt;

&lt;p&gt;In order to answer this, the authors analyzed Firefox Browser system and
implement an alternate extension system with the Chrome Extension System.&lt;/p&gt;

&lt;p&gt;One could say that the Firefox model at the time was silly and had lacked any
regard for security. However, it is important to remember that extensions were
meant to supplement a user&amp;rsquo;s experience and, before this point, the use case
for extensions wasn&amp;rsquo;t clear. Firefox had no idea what to expect, while the
authors of this paper benefited from hindsight.&lt;/p&gt;

&lt;p&gt;The threat model is &lt;em&gt;benign but buggy&lt;/em&gt; extensions: a malicious attacker could
corrupt the extension and usurp its privileges.&lt;/p&gt;

&lt;h4 id=&#34;evolution-of-firefox&#34;&gt;Evolution of Firefox&lt;/h4&gt;

&lt;p&gt;The paper argues that the underlying issue of the four potential (out of many)
attacks is that Firefox extensions interact directly with untrusted content
while possessing a high level of privilege &amp;mdash; by rethinking the architecture
they aren&amp;rsquo;t just fixing one problem, they are addressing most of them.&lt;/p&gt;

&lt;p&gt;While they argue that there was no way to automate the extension analysis, there
might have been a way to perform a program analysis to look at how the APIs are
used. On this note, while their paper did well with only 25 extensions from the
Firefox Extension system, it could have benefited from a larger analysis to
provide a better picture of how the average extension dealt with privileges.&lt;/p&gt;

&lt;p&gt;Out of the 25 extensions that they analyzed, 19 had &amp;lsquo;critical&amp;rsquo; privileges,
meaning that they could run arbitrary code on the user&amp;rsquo;s system, while only 3
required critical privileges. This is an example of a privilege gap.&lt;/p&gt;

&lt;p&gt;The paper then goes into discussing a security lattice that they used to
analyze the Firefox extension API. They show that there is a considerable
number of escalation points that need to be addressed, and that the separation
of privileges is not necessarily as easy as it seems. APIs need to be designed
from the start with privileges in mind.&lt;/p&gt;

&lt;p&gt;From this analysis, they propose building a new system following the principle
of least privilege, privilege separation, and strong isolation.&lt;/p&gt;

&lt;h4 id=&#34;google-chrome-extension-system&#34;&gt;Google Chrome Extension System&lt;/h4&gt;

&lt;p&gt;The Google chrome extension system implements privilege separation and isolation
mechanisms.&lt;/p&gt;

&lt;h5 id=&#34;why-did-they-need-both&#34;&gt;Why did they need both?&lt;/h5&gt;

&lt;p&gt;The privilege separation was broken into three differed hierarchies: &lt;em&gt;content
scripts&lt;/em&gt;, &lt;em&gt;extension core&lt;/em&gt;, and &lt;em&gt;native binary&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Content scripts are JavaScript scripts that allow extensions to directly
interact with the untrusted web content (DOM) &amp;mdash; since they have the largest
attack surface, they do not have any direct access to privileged APIs. They can
only communicate with the extension core via message passing.&lt;/p&gt;

&lt;p&gt;Extension cores have access to privileged APIs (which, for example, allow them
to create new tabs) as declared in the extension&amp;rsquo;s manifest and approved by the
user at install time.  The core does not interact with untrusted web content
directly; it can only communicate with untrusted context via the content script
or using an XMLHTTPRequest.&lt;/p&gt;

&lt;p&gt;Finally, the native binary can run arbitrary code or access arbitrary files.&lt;/p&gt;

&lt;p&gt;The isolation mechanisms are similarly split up into separate parts.
- Origins are used to ensure isolation between different extension cores. This,
  for example, ensures that one extension cannot mess with another&amp;rsquo;s
  &lt;code&gt;localStorage&lt;/code&gt;.
- Extension cores and native binaries are run in different OS processes. This
  ensures isolation between themselves and content.
- Content scripts run in &lt;em&gt;isolated worlds&lt;/em&gt;. They have a separate JavaScript
  heap and separate access to the DOM of the untrusted web page they run in.
  This ensures that content scripts are isolated from the untrusted content and
  other extensions (under the buggy but benign model).&lt;/p&gt;

&lt;h4 id=&#34;discussion&#34;&gt;Discussion&lt;/h4&gt;

&lt;p&gt;In order to evaluate their system, they measured page latency and DOM access
time &amp;mdash; both had increases, respectively 0.8ms and 33.3%. What was missing was
a lack of a user study to understand the implications of their system. In the
end, the hindsight from the Firefox extension system helped them a lot, because
they were able to see a (small) sample of how users use extensions and what
could go wrong.&lt;/p&gt;

&lt;p&gt;Today, the paper could be improved in various ways. You could look at more
extensions or determine more concretely what the APIs should look like, and,
given yet more hindsight, consider a more realistic attacker model.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NaCl</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/nacl/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0706</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/nacl/</guid>
      <description>

&lt;p&gt;Author: Shravan Narayan&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-high-level-goal&#34;&gt;What is the high level goal?&lt;/h4&gt;

&lt;p&gt;To be able to run native binaries securely, while incurring as little overhead
as possible to ensure the safety of the system.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-high-level-strategy&#34;&gt;What is the high level strategy?&lt;/h4&gt;

&lt;p&gt;This is done by ensuring that any faults or bug are isolated to the module, i.e.
the bug cannot be used to take over the entire system.&lt;/p&gt;

&lt;h4 id=&#34;why-do-you-want-native-code&#34;&gt;Why do you want native code?&lt;/h4&gt;

&lt;p&gt;Native code has the benefit of running on bare metal, i.e. there are no layers
of interpreters or virtual machines that are needed for them to operate. Thus
the performance of native code is significantly better than interpreted code of
virtual machine code.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-threat-model&#34;&gt;What is the threat model?&lt;/h4&gt;

&lt;p&gt;The threat model is one of where a malicious website creator may use native
binaries to take over your computer, or a malicious entity could try to take
over the computer by abusing a bug in one of the native binaries that are
currently loaded on to the browser by a website.&lt;/p&gt;

&lt;h4 id=&#34;what-are-the-inner-and-outer-sandboxes&#34;&gt;What are the inner and outer sandboxes?&lt;/h4&gt;

&lt;p&gt;NaCl implements its security by running native binaries on 2 layers of
sandboxes. The inner layer is a sandbox that implements fault isolation - i.e.
any bug in the program is isolated such that it cannot have an effect on the
rest on the system. The outer sandbox is an added safety mechanism - this is a
layer that restricts system calls to only a subset of allowed ones.  In the
Linux Chromium version, this is currently implemented via
&lt;a href=&#34;https://en.wikipedia.org/wiki/Seccomp&#34;&gt;seccomp-bpf&lt;/a&gt; which allow this sort of
system call filtering.&lt;/p&gt;

&lt;h4 id=&#34;how-is-the-software-isolation-enforced-in-the-inner-sandbox-in-nacl&#34;&gt;How is the software isolation enforced in the inner sandbox in NaCl?&lt;/h4&gt;

&lt;p&gt;Software isolation is enforced with the help of the x86 memory segmentation
features and an instruction verifier.  Segments ensure that the program cannot
read/write to parts of memory outside the untrusted code&amp;rsquo;s bounds. The
instruction verifier ensures that only safe (e.g., no memory jumps),
properly-aligned instructions are allowed. Bit masks are used to ensure that
jump instructions cannot jump to the middle of existing instructions.&lt;/p&gt;

&lt;h4 id=&#34;what-are-some-of-the-complications-with-parsing-x86-code-what-steps-are-taken-to-mitigate-these-complications&#34;&gt;What are some of the complications with parsing x86 code? What steps are taken to mitigate these complications?&lt;/h4&gt;

&lt;p&gt;x86 code has variable sized instructions. Even a particular instruction may
have representations in multiple lengths. This may be lead to non-aligned
overlapping instructions. Another challenge is self modifying code - which is
used in applications such as JIT code generation etc.&lt;/p&gt;

&lt;p&gt;To reduce the complexity, all instructions are aligned at word boundaries (aka
32 bit aligned), self modifying code is not allowed and all jump instructions
are forced to jump to word boundaries.&lt;/p&gt;

&lt;h4 id=&#34;what-are-examples-of-instructions-or-other-operations-not-allowed-by-nacl&#34;&gt;What are examples of instructions or other operations not allowed by NaCl?&lt;/h4&gt;

&lt;p&gt;NaCl blocks any instructions that allow changing the segment state, system
calls, interrupts and return aka long jump instructions (a modified long jump
called NaCl jump which is an and instruction followed jump is allowed. The and
instruction ensures that the jump instruction stays at word boundaries.)&lt;/p&gt;

&lt;h4 id=&#34;what-happens-if-we-don-t-mask-jumps-i-e-what-happens-if-we-allow-regular-jump-or-return-instructions-instead-of-nacl-jump&#34;&gt;What happens if we don&amp;rsquo;t mask jumps, i.e. what happens if we allow regular jump or return instructions instead of NaCl jump?&lt;/h4&gt;

&lt;p&gt;If we don&amp;rsquo;t mask jumps, a program vulnerability could allow the execution of
instructions that are not allowed such as segment instructions, by creatively
jumping in the middle of an existing instruction. If the location for the jump
is picked carefully, the middle of a target instruction could be read by the
processor as an instruction which we want to block.&lt;/p&gt;

&lt;h4 id=&#34;what-happens-if-we-don-t-use-segmented-memory&#34;&gt;What happens if we don&amp;rsquo;t use segmented memory?&lt;/h4&gt;

&lt;p&gt;Without segmented memory, there is nothing stopping a jump instruction to jump
to an arbitrary location outside the segment (e.g., to parts of the trusted
reference monitor). Thus we would need some other mechanism to enforce the
program memory isolation. One such technique is used in one of the papers
referred to in the NaCl paper - PittsField. The PittsField paper enforces this
isolation without segments by applying a bit mask on the most significant bits
before every jump to ensure the jump is confined to a part of the memory.&lt;/p&gt;

&lt;h4 id=&#34;what-are-the-various-components-included-in-a-nacl-applications-runtime&#34;&gt;What are the various components included in a NaCl applications runtime?&lt;/h4&gt;

&lt;p&gt;Each sandboxed application is run in an environment with the following pieces
- an inter module communications service: which allows communication between
  components, components and the browser via messages, shared memory segments
  and synchronization objects
- service runtime: which allows memory management APIs, thread creation interfaces etc.&lt;/p&gt;

&lt;h4 id=&#34;why-does-nacl-have-srpc-and-npapi&#34;&gt;Why does NaCl have SRPC and NPAPI?&lt;/h4&gt;

&lt;p&gt;SRPC is a protocol that allows communication between NaCl modules as well as
the JavaScript in the browser by declaring the procedural interface with basic
data types. NPAPI (Netscape Plugin API) is a protocol which is used to interact
with DOM, JS objects directly, etc. NPAPI is actually quite an old protocol
that is no longer used by NaCl. They have replaced this with a new protocol
called Pepper with the goal of better platform portability and security.&lt;/p&gt;

&lt;h4 id=&#34;how-is-the-isolation-provided-by-nacl-thwart-a-simple-buffer-overflow-vulnerability-that-gives-arbitrary-code-execution&#34;&gt;How is the isolation provided by NaCl thwart a simple buffer overflow vulnerability that gives arbitrary code execution?&lt;/h4&gt;

&lt;p&gt;NaCl does not prevent the buffer overflow, however, the buffer is stored in a
separate data segment. So, a buffer overflow cannot be used to overwrite the
return pointer on the stack. Also, this segment is separated from the rest of
the call stack and the memory page containing the data segment is marked as
no-execute and so cannot be executed.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-validator-what-are-the-use-cases-and-constraints&#34;&gt;What is the validator? What are the use cases and constraints?&lt;/h4&gt;

&lt;p&gt;The validator is a program that is used prior to loading a NaCl binary. This
program validates that a given NaCl binary confirms to all the rules about
using only allowed and word aligned instructions, masking jump locations, etc.
The validator thus needs to be able to efficiently parse x86 instructions - the
word alignment restriction as well as a small subset of allowed instructions
makes this simpler. As the validator is used just before loading the binary, it
is required that this operate with minimum overhead, so as to not introduce any
latency.&lt;/p&gt;

&lt;h4 id=&#34;the-paper-talks-about-exceptions-what-are-they-how-are-they-supported&#34;&gt;The paper talks about exceptions. What are they? How are they supported?&lt;/h4&gt;

&lt;p&gt;There are 2 types of exceptions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hardware exceptions: interrupts delivered by the OS such as floating point exceptions&lt;/li&gt;
&lt;li&gt;Software exceptions: the regular exceptions encountered by the language which
are handled by the try catch syntax.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hardware exceptions are not supported and will cause the NaCl program to be
terminated. This is because segmented memory modes were not very well supported
by the OS - i.e. the OS doesn&amp;rsquo;t have a mechanism to deliver exceptions to
processed which have modified the stack segment register.  Software exceptions
function as expected.&lt;/p&gt;

&lt;h4 id=&#34;are-system-calls-allowed-in-nacl-describe-the-mechanism-used-to-enable-block-this&#34;&gt;Are system calls allowed in NaCl? Describe the mechanism used to enable/block this?&lt;/h4&gt;

&lt;p&gt;System calls are not directly allowed. However NaCl provides a mediated
approach to some functions, including system calls, with the help of trampolines
and springboards. These mechanisms are implemented as part of the Service
Runtime. Trampolines are trusted code that removes the segment restrictions,
and calls into unsandboxed code. This code executes and returns via the
springboard. The springboard resets these stack restrictions. Note that the
springboard code is also used as to provide the threading interface for a NaCl
binary - however this cannot be invoked directly by the sanboxed NaCl app.&lt;/p&gt;

&lt;h4 id=&#34;the-paper-describes-a-particular-memory-layout-for-nacl-binaries-what-are-the-benefits&#34;&gt;The paper describes a particular memory layout for NaCl binaries? What are the benefits?&lt;/h4&gt;

&lt;p&gt;The memory layout starts with one page (4kb) of unallocated space - this is
used to detect null pointer exceptions as any reference to this memory will
cause a page fault. The next 60 KB is used by the service runtime to load the
trusted trampoline and springboard code. Trampolines can only contain function
whose entries are at word boundaries as they need to be callable by the NaCl
binary. The springboard should not be called directly by the NaCl binary as it
manipulates segment information and so have entries that are not word aligned.&lt;/p&gt;

&lt;h4 id=&#34;what-were-some-of-the-modifications-required-to-the-compilers-to-generate-nacl-binaries&#34;&gt;What were some of the modifications required to the compilers to generate NaCl binaries?&lt;/h4&gt;

&lt;p&gt;GCC was modified to ensure&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;function entries were only at word boundaries&lt;/li&gt;
&lt;li&gt;branch targets are 32 bit aligned&lt;/li&gt;
&lt;li&gt;to use nacljump for indirect transfers&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-is-the-overhead-of-a-nacl-binary&#34;&gt;What is the overhead of a NaCl binary?&lt;/h4&gt;

&lt;p&gt;Several benchmarks were run to estimate overhead - the average overhead seems
to be about 5%. Benchmarks included SPEC2000, graphics tests, video decoding,
physics simulations, and games. The equally important metric was the latency
overhead of the NaCl verifier, which was measured to be on the order of
30MB/second (small compared to download time).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Verena</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/verena/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0705</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/verena/</guid>
      <description>

&lt;p&gt;Author: Zhaomo Yang&lt;/p&gt;

&lt;h4 id=&#34;the-foundation-that-verena-relies-on&#34;&gt;The foundation that Verena relies on.&lt;/h4&gt;

&lt;p&gt;Verena is based on some ideas from Mylar, which is briefly mentioned in III-A.
Specifically, the authors assume:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A web page that the app client receives consists of two separate parts: a
static web page (code) and data;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The static page is signed by the developer. The signature is verified by the
Verena browser extension, which has the developer&amp;rsquo;s public key.  From now on,
let&amp;rsquo;s assume that the web page has verified.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;the-architecture-of-verena&#34;&gt;The architecture of Verena.&lt;/h4&gt;

&lt;p&gt;Verena consists of the following parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The browser that runs the client-side program (including the app client and
the Verena client)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The server that runs the server-side program (including the app server and
the Verena server)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The app client and the app server are just normal web app clients and servers.
The Verena client and the Verena server speak the Verena protocol. There are places where the Verena mechanisms operate.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The identity provider (IDP) provides the public key for a given user (The
paper doesn&amp;rsquo;t really talk about it too much).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The hash server (HS) provides signed hashes, which can help the client verify
the proofs received from the server.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;thread-model-and-goal&#34;&gt;Thread model and goal&lt;/h4&gt;

&lt;p&gt;The server and HS, or the server and IDP cannot be both compromised.  Under
this assumption, Verena ensures that the client can notice if the data received
is not correct, fresh or complete (what they define as integrity).&lt;/p&gt;

&lt;h4 id=&#34;trust-contexts&#34;&gt;Trust Contexts&lt;/h4&gt;

&lt;p&gt;A trust context consists of a set of principals. Also, when it is associated
with a set of queries, it means that the results of the queries can only be
affected by the principals in the trust context.&lt;/p&gt;

&lt;h4 id=&#34;integrity-query-prototypes&#34;&gt;Integrity Query Prototypes&lt;/h4&gt;

&lt;p&gt;A Integrity Query Prototype (IQP), defined on a collection &lt;code&gt;C&lt;/code&gt;, consists of&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A trust context &lt;code&gt;TC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A read query pattern that decides a query set &lt;code&gt;Q_set&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given a query, Verena can determine which principals can affect its result by using IQPs.&lt;/p&gt;

&lt;h4 id=&#34;verena-protocols&#34;&gt;Verena protocols&lt;/h4&gt;

&lt;h5 id=&#34;reads&#34;&gt;Reads&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;The app client asks the Verena client to execute a query through a IQP&lt;/li&gt;
&lt;li&gt;The Verena client checks if it is the correct IQP. If it is, send the query
with a nonce (prevent replay attacks) to the server. Also, based on the IQP,
the Verena client knows the trust context of the query.&lt;/li&gt;
&lt;li&gt;The Verena server runs the query and also creates the proof for the result.
In addition, it figures out what hashes the Verena client needs to verify the
proof, then send hash requests, along with nonce from the client, to HS.&lt;/li&gt;
&lt;li&gt;The HS gets the requested hashes, and signs the hash requests, hashes, and
nonce into. It the sends this to the server.&lt;/li&gt;
&lt;li&gt;The Verena server then sends the result, the proof, and the signature from HS
to the Verena client.&lt;/li&gt;
&lt;li&gt;The Verena client verifies the proof to check the integrity of the result.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;writes&#34;&gt;Writes&lt;/h5&gt;

&lt;p&gt;The write protocol is similar to the read protocol, except it has one
additional step: The Verena client needs to help update the affected hashes of
the query. The Verena client, or more specifically the underlying principal
must be involved otherwise a compromised server can send HS fake hash updates.
The extra step happens after the second step in the read protocol&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The Verena server passes the related information to the Verena client,
including the entries (each entry consists of a hash, a version number and
the public key of the writer) on HS that are to be updated.
(Note the Verena server has all the information the HS has.)&lt;/li&gt;
&lt;li&gt;The Verena client calculates the new entries for HS, signs both new and old
entries, and passes the signature to the Verena server.&lt;/li&gt;
&lt;li&gt;The Verena server verifies the signature. If everything is OK, it updates its
copies of hashes (as mentioned before, the Verena server has all the
hashes HS has), and sends the signature to the HS to let HS update its hashes.&lt;/li&gt;
&lt;li&gt;The HS verifies the signature from the client and updates the entries.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that the Verena server sending its own copy of the old entries to the
client is only an optimization technique. Alternatively, the Verena server
could have just requested that from the HS, and the HS could have sent the
signed old entries. Obviously, this would be slow. Note, that because of this
optimization, a compromised server can send fake old entries to the client.
This is why the Verena client needs to additionally sign the old entries. On
the HS side: when the HS receives the signature from the client, it checks if
the signed old entries are the same as the ones it already has. If not, it will
reject the update since that would indicate that the server is has been
compromised.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hails</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/hails/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0704</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/hails/</guid>
      <description>

&lt;p&gt;Author: Matthew Chan&lt;/p&gt;

&lt;h3 id=&#34;what-is-the-main-contribution-of-the-paper&#34;&gt;What is the main contribution of the paper?&lt;/h3&gt;

&lt;p&gt;Aside from the artefact, the Model-&lt;em&gt;Policy&lt;/em&gt;-View-Controller architecture, which
provides a framework for building IFC enabled web applications.&lt;/p&gt;

&lt;h3 id=&#34;what-problem-does-mpvc-solve&#34;&gt;What problem does MPVC solve?&lt;/h3&gt;

&lt;p&gt;Traditional web application structure (i.e. MVC) has security checks littered
across the code base, mostly in the controllers &amp;ndash; the situation does not
improve across different kinds of frameworks, both client and server side View
frameworks suffer from the same problem (e.g. user metadata sanitization in the
view).  Specifying policy this way has two major disadvantages (a) policies have
to be specified multiple times for the same piece of data, leading to (b)
forgotten checks, inconsistent policies, and difficulties with revising the policies.&lt;/p&gt;

&lt;p&gt;MPVC allows for the centralised specification of security policies where they
logically belong (with the data) thus simplifying the view and controller by
making redundant checks in those components. This needs to be supported by a
runtime =&amp;gt; Hails.&lt;/p&gt;

&lt;h3 id=&#34;what-are-principals-what-are-the-three-types-of-principals-in-hails&#34;&gt;What are principals? What are the three types of principals in Hails?&lt;/h3&gt;

&lt;p&gt;A principal is a participant in the system who is allowed to read and write
data. Policies are specified in terms of principals. Unforgeable tokens called
&lt;em&gt;privileges&lt;/em&gt; represent the authority of principals at runtime.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Users&lt;/li&gt;
&lt;li&gt;VCs and remote resources they communicate with&lt;/li&gt;
&lt;li&gt;MPs&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;the-hails-dsl-allows-policies-to-be-specified-via-arbitrary-actions-does-this-affect-the-design-of-dclabels&#34;&gt;The Hails DSL allows policies to be specified via arbitrary actions. Does this affect the design of DCLabels?&lt;/h3&gt;

&lt;p&gt;It should not, since the labels evaluate to the same thing cf. policies
specified as pure functions, you still get a label in the DCLabels format. The
DSL affects only expressivity, and is safe with IFC controlled effects.&lt;/p&gt;

&lt;h3 id=&#34;how-is-the-hails-labelled-db-api-different-from-the-mp-dsl-does-one-get-the-same-guarantees-if-she-does-not-use-the-dsl&#34;&gt;How is the Hails labelled DB API different from the MP DSL? Does one get the same guarantees if she does not use the DSL?&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;MPs may contain arbitrary code and can expose an arbitrary API&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Hails DB API: wraps the underlying DB API with labels, part of the Hails TCB.&lt;/li&gt;
&lt;li&gt;MP DSL: for describing MPs, which translate to calls to the DB API.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The DB API can be used to express things that maybe the DSL cannot. This is
purely a matter of convenience; things are safe as long as the Hails libraries
are used (policy is mandated by the Hails runtime anyways).&lt;/p&gt;

&lt;h3 id=&#34;how-are-things-labelled-in-hails&#34;&gt;How are things labelled in Hails?&lt;/h3&gt;

&lt;p&gt;See Fig. 2 on pg. 7&lt;/p&gt;

&lt;p&gt;The Hails MP persistence model is based on a document-oriented model (similar to Mongo), where&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DB = { collection } (≈ tables)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Every database has a label&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;collection = { document } (≈ rows)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Every collection in a database has a collection label&lt;/p&gt;

&lt;p&gt;MPs can specify coarse-grained DB and coll labels.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;document = { field } (≈ K-V mappings).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fields can be indexed &lt;em&gt;keys&lt;/em&gt; identifying the document or non-indexed
  &lt;em&gt;elements&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Documents and Fields can be labelled via a function of type &lt;code&gt;Doc -&amp;gt; Label&lt;/code&gt;,
  i.e. label depends on document contents.&lt;/p&gt;

&lt;h3 id=&#34;why-does-hails-need-os-level-confinement-and-how-is-this-different-from-threads-are-there-alternative-designs-for-this-mechanism&#34;&gt;Why does Hails need OS level confinement and how is this different from threads? Are there alternative designs for this mechanism?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;For running external programs, i.e. &lt;code&gt;splint&lt;/code&gt; linter in the &lt;code&gt;gitstar&lt;/code&gt; example&lt;/li&gt;
&lt;li&gt;Threads =/= Processes; a process can have many threads. Spawning threads in
Hails/LIO is completely fine, the child thread acquires the label of its
parent.&lt;/li&gt;
&lt;li&gt;This confinement does not extend to spawned processes, so we need a kernel
level confinement solution. Hails uses standard Linux isolation mechanisms,
but other sandbox/container solutions might also work, i.e. Docker.&lt;/li&gt;
&lt;li&gt;As discussed in class, a possible design might be to &amp;ldquo;flip&amp;rdquo; the process model and
have all processes communicate via the safe Hails/LIO process. This way all IO
is labelled and spawned processes can have access to the network and other
resources. Sadly this doesn&amp;rsquo;t work because of label creep. (explain the
problem in detail?)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;how-is-hails-evaluated&#34;&gt;How is Hails evaluated?&lt;/h3&gt;

&lt;p&gt;Same as Shill:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Expressiveness/usability:&lt;/strong&gt; built a few applications with Hails, including one
by a team of undergraduate research interns who were novices in Haskell and
Hails. Found that MP was hard to get right but extension with VC is easy.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Performance:&lt;/strong&gt; Evaluation against existing mainstream web frameworks, mostly
demonstrating that interpreted languages (like Ruby) are terrible.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Performance is competitive cf. Java but&amp;hellip;&lt;/li&gt;
&lt;li&gt;DB performance is bad (mostly due to the Haskell Mongo library implementation,
according to Deian)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Security:&lt;/strong&gt; this is the focal point. Tiny TCB in application code across all
examples. How big is the TCB for the Hails library + runtime +
LIO/DCLabels/COWL ecosystem?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The other parts are formalized in Coq :+1:&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;another-policy-enforcing-framework-is-jeeves-jacqueline-how-is-hails-different&#34;&gt;Another policy enforcing framework is Jeeves/Jacqueline. How is Hails different?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Jeeves is a language, whereas Hails is a library/EDSL. This makes Hails more
flexible and easier to change from a language design point of view. (+ usual
host-language features for free argument for EDSLs)&lt;/li&gt;
&lt;li&gt;LIO&amp;rsquo;s programming model is more flexible (e.g., LIO has exceptions and threads).&lt;/li&gt;
&lt;li&gt;Jeeves is completely policy agnostic; Hails is &lt;em&gt;mostly&lt;/em&gt; policy agnostic. The
authors make a case for requiring policies be inspectable, i.e. to recover
from failures (see concurrent LIO).&lt;/li&gt;
&lt;li&gt;Jeeves can specify policies on concrete data stored in DB directly, Hails
requires a layer of indirection at the MP level. Unclear which is better.&lt;/li&gt;
&lt;li&gt;Hails has a story for confinement in the browser, via COWL, and for
enforcement at the OS level.&lt;/li&gt;
&lt;li&gt;LIO addresses covert channels and generally has a stronger attacker model.
Specifically, LIO supports termination sensitive noninterference (no leaks
via termination channel). Jeeves supports termination insensitive
noninterference (leaks via termination channel possible).&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Resin</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/resin/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0703</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/resin/</guid>
      <description>

&lt;p&gt;Author: Caroline Kim&lt;/p&gt;

&lt;h4 id=&#34;what-challenges-does-resin-aim-to-address&#34;&gt;What challenges does Resin aim to address?&lt;/h4&gt;

&lt;p&gt;Resin is a language runtime that equips programmers with the ability to encode and enforce data flow assertions. Resin provides data flow tracking while requiring few changes to the existing code.&lt;/p&gt;

&lt;h4 id=&#34;which-security-vulnerabilities-would-resin-catch-and-which-would-it-not&#34;&gt;Which security vulnerabilities would Resin catch and which would it not?&lt;/h4&gt;

&lt;p&gt;Main use case is protecting against web application vulnerabilities such as SQLi/XSS. It is assumed that both the entire language runtime and the application code itself is trustworthy &amp;ndash; Resin does not protect against bugs in this code.&lt;/p&gt;

&lt;p&gt;Resin does not catch implicit data flows such as those resulting from conditional branch and ordering of data.  Hence, the attacker model assumes that the application code itself is also trustworthy.&lt;/p&gt;

&lt;h4 id=&#34;how-does-resin-enforce-assertions&#34;&gt;How does Resin enforce assertions?&lt;/h4&gt;

&lt;p&gt;Through filter objects and policy objects. Policy objects are defined for data and filter objects are defined for channels. Assertions for data can be specified in policy objects through &lt;code&gt;export_check&lt;/code&gt; which will be called by filter objects.&lt;/p&gt;

&lt;p&gt;By having this separation, developers can revise policy objects without having to worry about all the filter objects.&lt;/p&gt;

&lt;h4 id=&#34;what-are-default-filter-objects&#34;&gt;What are default filter objects?&lt;/h4&gt;

&lt;p&gt;By default, Resin creates filter objects at the &amp;ldquo;edge of the runtime.&amp;rdquo; This encompasses all the runtime I/O, including sockets, HTTP layer, SQL layer, and other code imports. Less work for developers!&lt;/p&gt;

&lt;h4 id=&#34;how-does-resin-handle-data-tracking&#34;&gt;How does Resin handle data tracking?&lt;/h4&gt;

&lt;p&gt;Data objects are tagged with policy objects at the primitive-level (integer, character in a string, and files).&lt;/p&gt;

&lt;h4 id=&#34;how-do-several-assertions-co-exist-for-a-file&#34;&gt;How do several assertions co-exist for a file?&lt;/h4&gt;

&lt;p&gt;Multiple policy objects can be attached to a file as part of a policy set.  Policy objects are attached to data in a fine-grained manner via a merge. When a merge is needed Resin, by default, takes the union of policy objects. But this merge policy can be overridden.&lt;/p&gt;

&lt;h4 id=&#34;why-does-resin-serialize-policy-objects&#34;&gt;Why does Resin serialize policy objects?&lt;/h4&gt;

&lt;p&gt;For persistently stored data, Resin serializes policy objects so they don&amp;rsquo;t have to be saved manually.&lt;/p&gt;

&lt;p&gt;Importantly, only class names and field values are serialized; this allows policy object code to change without having to rewrite serialized policies.&lt;/p&gt;

&lt;h4 id=&#34;how-do-the-authors-evaluate-resin&#34;&gt;How do the authors evaluate Resin?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Security: Lines of code (how easy is it for developers), preventing vulnerability (100%?), whether it works properly on edge cases&lt;/li&gt;
&lt;li&gt;Performance: Overhead is 33%, overall. Higher when policy is present and a lot higher for those involving SQL operations (parsing the query is required)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>