<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]> <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]> <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Verena  &middot; CSE 291</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="description" content="" />

<meta name="keywords" content="">


<meta property="og:title" content="Verena  &middot; CSE 291 ">
<meta property="og:site_name" content="CSE 291"/>
<meta property="og:url" content="https://cse291.programming.systems/notes/verena/" />
<meta property="og:locale" content="en-us">


<meta property="og:type" content="article" />
<meta property="og:description" content=""/>
<meta property="og:article:published_time" content="2016-09-23T01:37:21-07:05" />
<meta property="og:article:modified_time" content="2016-09-23T01:37:21-07:05" />

  

  
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@deiandelmars" />
<meta name="twitter:creator" content="@deiandelmars" />
<meta name="twitter:title" content="Verena" />
<meta name="twitter:description" content="" />
<meta name="twitter:url" content="https://cse291.programming.systems/notes/verena/" />
<meta name="twitter:domain" content="https://cse291.programming.systems">
  

<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "Article",
    "headline": "Verena",
    "author": {
      "@type": "Person",
      "name": "http://profiles.google.com/+?rel=author"
    },
    "datePublished": "2016-09-23",
    "description": "",
    "wordCount":  784 
  }
</script>



<link rel="canonical" href="https://cse291.programming.systems/notes/verena/" />

<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://cse291.programming.systems/touch-icon-144-precomposed.png">
<link href="https://cse291.programming.systems/favicon.png" rel="icon">
<meta name="theme-color" content="#2053AB">
<meta name="generator" content="Hugo 0.16" />

  <!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

<link href='https://fonts.googleapis.com/css?family=Merriweather:300%7CRaleway%7COpen+Sans' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="https://cse291.programming.systems/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cse291.programming.systems/css/style.css">
<link rel="stylesheet" href="https://cse291.programming.systems/css/highlight/default.css">

  
</head>
<body>
  <main id="main-wrapper" class="container main_wrapper has-sidebar">
    <header id="main-header" class="container main_header">
  <div class="container brand">
  <div class="container title h1-like">
  <a class="baselink" href="https://cse291.programming.systems">
  CSE 291

</a>

</div>

  
<div class="container topline">
  
  Building Secure Systems using Programming Languages and Analysis


</div>


</div>

  <nav class="container nav primary no-print">
  


  
<a href="https://cse291.programming.systems/about">Organization</a>

<a href="https://cse291.programming.systems/syllabus" title="Course syllabus">Syllabus</a>

<a href="https://cse291.programming.systems/contact">Contact</a>

<a href="https://cse291.programming.systems/notes">Notes</a>

<a href="https://cse291.programming.systems/assignments">Assignments</a>

<a href="https://cse291.programming.systems/ideas">Project ideas</a>


</nav>

<div class="container nav secondary no-print">
  
<a id="contact-link-email" class="contact_link" href="mailto:deian&#43;cse291@cs.ucsd.edu">
  <span class="fa fa-envelope-square"></span><span>email</span></a>



<a id="contact-link-github" class="contact_link" href="https://github.com/plsyssec/cse291-fall16">
  <span class="fa fa-github-square"></span><span>github</span></a>











<a id="contact-link-twitter" class="contact_link" href="https://twitter.com/deiandelmars">
  <span class="fa fa-twitter-square"></span><span>twitter</span></a>











</div>


  

</header>


<article id="main-content" class="container main_content single">
  <header class="container hat">
  <h1>Verena
</h1>

</header>

  <div class="container content">
  

<p>Author: Zhaomo Yang</p>

<h4 id="the-foundation-that-verena-relies-on">The foundation that Verena relies on.</h4>

<p>Verena is based on some ideas from Mylar, which is briefly mentioned in III-A.
Specifically, the authors assume:</p>

<ul>
<li><p>A web page that the app client receives consists of two separate parts: a
static web page (code) and data;</p></li>

<li><p>The static page is signed by the developer. The signature is verified by the
Verena browser extension, which has the developer&rsquo;s public key.  From now on,
let&rsquo;s assume that the web page has verified.</p></li>
</ul>

<h4 id="the-architecture-of-verena">The architecture of Verena.</h4>

<p>Verena consists of the following parts:</p>

<ul>
<li><p>The browser that runs the client-side program (including the app client and the Verena client)</p></li>

<li><p>The server that runs the server-side program (including the app server and the Verena server)</p></li>
</ul>

<p>The app client and the app server are just normal web app clients and servers.
The Verena client and the Verena server speak the Verena protocol. There are places where the Verena mechanisms operate.</p>

<ul>
<li><p>The identity provider (IDP) provides the public key for a given user (The paper doesn&rsquo;t really talk about it too much).</p></li>

<li><p>The hash server (HS) provides signed hashes, which can help the client verify the proofs received from the server.</p></li>
</ul>

<h4 id="thread-model-and-goal">Thread model and goal</h4>

<p>The server and HS, or the server and IDP cannot be both compromised.  Under
this assumption, Verena ensures that the client can notice if the data received
is not correct, fresh or complete (what they define as integrity).</p>

<h4 id="trust-contexts">Trust Contexts</h4>

<p>A trust context consists of a set of principals. Also, when it is associated
with a set of queries, it means that the results of the queries can only be
affected by the principals in the trust context.</p>

<h4 id="integrity-query-prototypes">Integrity Query Prototypes</h4>

<p>A Integrity Query Prototype (IQP), defined on a collection <code>C</code>, consists of</p>

<ul>
<li>A trust context <code>TC</code></li>
<li>A read query pattern that decides a query set <code>Q_set</code></li>
</ul>

<p>Given a query, Verena can determine which principals can affect its result by using IQPs.</p>

<h4 id="verena-protocols">Verena protocols</h4>

<h5 id="reads">Reads</h5>

<ul>
<li>The app client asks the Verena client to execute a query through a IQP</li>
<li>The Verena client checks if it is the correct IQP. If it is, send the query
with a nonce (prevent replay attacks) to the server. Also, based on the IQP,
the Verena client knows the trust context of the query.</li>
<li>The Verena server runs the query and also creates the proof for the result.
In addition, it figures out what hashes the Verena client needs to verify the
proof, then send hash requests, along with nonce from the client, to HS.</li>
<li>The HS gets the requested hashes, and signs the hash requests, hashes, and
nonce into. It the sends this to the server.</li>
<li>The Verena server then sends the result, the proof, and the signature from HS
to the Verena client.</li>
<li>The Verena client verifies the proof to check the integrity of the result.</li>
</ul>

<h5 id="writes">Writes</h5>

<p>The write protocol is similar to the read protocol, except it has one
additional step: The Verena client needs to help update the affected hashes of
the query. The Verena client, or more specifically the underlying principal
must be involved otherwise a compromised server can send HS fake hash updates.
The extra step happens after the second step in the read protocol</p>

<ul>
<li>The Verena server passes the related information to the Verena client,
including the entries (each entry consists of a hash, a version number and
the public key of the writer) on HS that are to be updated.
(Note the Verena server has all the information the HS has.)</li>
<li>The Verena client calculates the new entries for HS, signs both new and old
entries, and passes the signature to the Verena server.</li>
<li>The Verena server verifies the signature. If everything is OK, it updates its
copies of hashes (as mentioned before, the Verena server has all the
hashes HS has), and sends the signature to the HS to let HS update its hashes.</li>
<li>The HS verifies the signature from the client and updates the entries.</li>
</ul>

<p>Note that the Verena server sending its own copy of the old entries to the
client is only an optimization technique. Alternatively, the Verena server
could have just requested that from the HS, and the HS could have sent the
signed old entries. Obviously, this would be slow. Note, that because of this
optimization, a compromised server can send fake old entries to the client.
This is why the Verena client needs to additionally sign the old entries. On
the HS side: when the HS receives the signature from the client, it checks if
the signed old entries are the same as the ones it already has. If not, it will
reject the update since that would indicate that the server is has been
compromised.</p>

</div>


  
</article>
      <footer id="main-footer" class="container main_footer">
  

  <div class="container nav foot no-print">
  

  <a class="toplink" href="#">back to top</a>

</div>

  <div class="container credits">
  
<div class="container footline">
  

</div>


  

</div>

</footer>

    </main>
    


<script src="https://cse291.programming.systems/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




    
  </body>
</html>

