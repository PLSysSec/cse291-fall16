<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes on CSE 291</title>
    <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/</link>
    <description>Recent content in Notes on CSE 291</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</managingEditor>
    <webMaster>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</webMaster>
    <lastBuildDate>Thu, 17 Nov 2016 01:37:21 -0702</lastBuildDate>
    <atom:link href="https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Ironclad Apps</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/ironclad-apps/</link>
      <pubDate>Thu, 17 Nov 2016 01:37:21 -0702</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/ironclad-apps/</guid>
      <description>

&lt;p&gt;Author: Fucheng Gao&lt;/p&gt;

&lt;h4 id=&#34;what-conference-did-this-paper-present-in&#34;&gt;What conference did this paper present in?&lt;/h4&gt;

&lt;p&gt;USENIX Symposium on Operating Systems Design and Implementation (OSDI)&lt;/p&gt;

&lt;h4 id=&#34;what-kind-of-need-is-satisfied-by-ironclad&#34;&gt;What kind of need is satisfied by Ironclad?&lt;/h4&gt;

&lt;p&gt;People want to assure their data secure when running apps in the could, without
trusting the cloud provider.&lt;/p&gt;

&lt;h4 id=&#34;what-s-the-shortcoming-of-previous-work-on-verification&#34;&gt;What&amp;rsquo;s the shortcoming of previous work on verification?&lt;/h4&gt;

&lt;p&gt;Currently software verification can provide strong guarantees, but the cost is
often high &amp;ndash; e.g., seL4 took over 20-person years.&lt;/p&gt;

&lt;h4 id=&#34;system-features&#34;&gt;System features&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;It can completely verify the software stack, which means it assume every part
of software is untrusted, e.g. OS, BIOS, etc.&lt;/li&gt;
&lt;li&gt;The verification is on low-level assembly, meaning some of the toolsets
(e.g., DafnyCC) need not not trusted.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;goals&#34;&gt;Goals&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Remote equivalence: A remote user should receive the same sequence
of messages as a user communicating with the app abstract state machine.&lt;/li&gt;
&lt;li&gt;Secure channel: Remote user can establish a secure channel to the app, in
the presence of an untrusted OS.&lt;/li&gt;
&lt;li&gt;Completeness: Every software component must be verified.&lt;/li&gt;
&lt;li&gt;Low level verification: verify the actual instruction to that are executed.&lt;/li&gt;
&lt;li&gt;Rapid development by systems programmers: Non-expert developers should be
able to rapidly develop a verified Ironclad app.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;non-goals&#34;&gt;Non-goals&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Compatibility&lt;/li&gt;
&lt;li&gt;Performance&lt;/li&gt;
&lt;li&gt;Covert-channels&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;main-techniques-used-by-ironclad&#34;&gt;Main techniques used by Ironclad&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Late launch: Run application in a protected environment&lt;/li&gt;
&lt;li&gt;Trusted computing: Tight software to a encryption key&lt;/li&gt;
&lt;li&gt;Software verification: Prove software action follows specification&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;threat-model&#34;&gt;Threat model&lt;/h4&gt;

&lt;p&gt;Provide security against software-based attackers, who may run arbitrary
software on machine before executing or after app executes. The adversary may
attack the BIOS, OS, etc.&lt;/p&gt;

&lt;p&gt;Ironclad only provides privacy and integrity; no liveness/DOS or consideration
for covert-channel attacks.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-tpm-trusted-platform-module-and-how-is-it-used-by-ironclad&#34;&gt;What is the TPM (Trusted Platform Module) and how is it used by Ironclad?&lt;/h4&gt;

&lt;p&gt;The TPM offers facilities for the secure generation of cryptographic keys,
random number generation, signing with the platform key, etc.&lt;/p&gt;

&lt;p&gt;The TPM is used by Ironclad to prove to the remote user that the app they think
is running is indeed that; i.e., the TPM is use for attestation. See
(TXT)[&lt;a href=&#34;https://en.wikipedia.org/wiki/Trusted_Execution_Technology&#34;&gt;https://en.wikipedia.org/wiki/Trusted_Execution_Technology&lt;/a&gt;] for modern usages.&lt;/p&gt;

&lt;h4 id=&#34;developer-workflow&#34;&gt;Developer workflow&lt;/h4&gt;

&lt;p&gt;Firsts, the developer write the high-level specification (trusted) and then
implements the app in Dafny (untrusted), using Hoare logic pre and post
conditions to make aid the verification. Using a specification translator, the
high-level spec will be translate to a BoogieX86 specification. The DafnyCC
complier will also compile the implementation into BoogieX86.  The verifier
will then verify if assembly code &amp;ldquo;matches&amp;rdquo; the spec. Finally, the trusted
assembler and linker produces the final binary.&lt;/p&gt;

&lt;h4 id=&#34;what-kind-of-specification-types-does-ironclad-rely-on&#34;&gt;What kind of specification types does Ironclad rely on?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Hardware specifications&lt;/li&gt;
&lt;li&gt;App Specifications&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-does-ironclad-simplify-hardware-specifications&#34;&gt;How does Ironclad simplify hardware specifications?&lt;/h4&gt;

&lt;p&gt;It only defines spec for the introductions it can reason about and uses in the
compilation stages; this is only slightly less than 60 instructions.&lt;/p&gt;

&lt;h4 id=&#34;how-does-ironclad-reduce-app-verification-cost&#34;&gt;How does Ironclad reduce app verification cost?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Preliminary verification: It performs a basic verification on Dafny code via
Z3. This lets developers quickly detect bugs when programming.&lt;/li&gt;
&lt;li&gt;Modular verification&lt;/li&gt;
&lt;li&gt;Shared verification&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;besides-functional-correctness-what-else-does-ironclad-prove&#34;&gt;Besides functional correctness what else does Ironclad prove?&lt;/h4&gt;

&lt;p&gt;They ensure privacy by proving noninterference. This is proved via Boogie&amp;rsquo;s
SymDiff.&lt;/p&gt;

&lt;h4 id=&#34;why-is-noninterference-not-usually-practical-for-real-apps&#34;&gt;Why is noninterference not usually practical for real apps?&lt;/h4&gt;

&lt;p&gt;Apps need to leak data. To this end, Ironclad introduced declassification via a
state machine.&lt;/p&gt;

&lt;h4 id=&#34;how-was-remote-equivalence-proved&#34;&gt;How was remote equivalence proved?&lt;/h4&gt;

&lt;p&gt;In short: they prove functional correctness for the declsssifier and noninterference for
the program up to the declassify statement and after it.&lt;/p&gt;

&lt;h4 id=&#34;what-feature-does-dafnycc-provide&#34;&gt;What feature does DafnyCC provide?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Type safety&lt;/li&gt;
&lt;li&gt;Array bound safety&lt;/li&gt;
&lt;li&gt;Transitive stack safety&lt;/li&gt;
&lt;li&gt;High-level property preservation&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-is-late-launch&#34;&gt;What is late-launch?&lt;/h4&gt;

&lt;p&gt;It resets the CPU to a known state, stores a measurement (hash) of the
in-memory code pointed to by the instructionâ€™s argument, and jumps to that
code. After a late-launch, the hardware provides the program control of the CPU
and 64 KiB of protected memory.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Singularity</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/singularity/</link>
      <pubDate>Tue, 15 Nov 2016 01:37:21 -0703</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/singularity/</guid>
      <description>

&lt;p&gt;Author: Deian Stefan&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-motivation-behind-singularity-and-more-broadly-a-message-passing-os&#34;&gt;What is the motivation behind Singularity and, more broadly, a message passing OS?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Bugs/vulnerabilities in existing systems due to interaction between different
components. In the OS world, device drivers are plagued by vulnerabilities.&lt;/li&gt;
&lt;li&gt;Isolation between different components: bugs in one wont affect other&lt;/li&gt;
&lt;li&gt;In the real world, we want message passing for device drivers, browser
extensions, plugins, ets&lt;/li&gt;
&lt;li&gt;Low-level languages are prone to UAFs and memory leaks.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;They believe that these problems can be addressed by high-level languages and message passing.&lt;/p&gt;

&lt;p&gt;Shared messaging only &lt;em&gt;seems&lt;/em&gt; simple; in practice it gets complicated once you
need to worry about races. Locks and barriers are not easy to use.&lt;/p&gt;

&lt;h4 id=&#34;what-are-the-limitations-downsides-of-existing-message-passing-systems&#34;&gt;What are the limitations/downsides of existing message passing systems?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Complicated programming models&lt;/li&gt;
&lt;li&gt;Performance due to copying data&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-is-the-big-downside-of-high-level-languages&#34;&gt;What is the big downside of high-level languages?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;GC, and directly: performance&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;at-a-high-level-how-does-singularity-address-this&#34;&gt;At a high-level, how does Singularity address this?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;SIPs (software isolated processes) run in isolation from each other.

&lt;ul&gt;
&lt;li&gt;In general most things process handles are GCd.&lt;/li&gt;
&lt;li&gt;Can allocate data in the exchange heap to share with other processes. This
data is manually managed.&lt;/li&gt;
&lt;li&gt;No dynamically loaded code (can&amp;rsquo;t reason about ownership etc.)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Only communication between processes: channels.&lt;/li&gt;
&lt;li&gt;Can send scalars, channel end points and pointers on the exchange heap to
other SIPs.

&lt;ul&gt;
&lt;li&gt;Ownership model ensures memory safety.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;why-is-singularity-so-fast&#34;&gt;Why is Singularity so fast?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Context switching is cheap: no user-priv mode, no MMU to get in the way, all
isolation is done in software. Only marginally more expensive than a function
call.&lt;/li&gt;
&lt;li&gt;Message passing is cheap: no allocation, the 0-copy sends means only pointer
is sent and no data is copied. (Trade-off? programming model + flexibility)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-do-they-mean-when-they-say-memory-safety&#34;&gt;What do they mean when they say memory safety?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;No UAFs&lt;/li&gt;
&lt;li&gt;No memory leaks&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-do-they-address-this&#34;&gt;How do they address this?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Only one SIP can &lt;em&gt;own&lt;/em&gt; a block in the exchange heap.&lt;/li&gt;
&lt;li&gt;When you send pointer as message to another heap, they are now the owner of
this block. You can no longer use the pointer.&lt;/li&gt;
&lt;li&gt;They ensure this statically by tracking ownership at the language level:

&lt;ul&gt;
&lt;li&gt;You get ownership by allocating, as function parameter, or return value.&lt;/li&gt;
&lt;li&gt;You lose ownership when you call function or call delete.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Invariants: only 1 owner (UAF), owner must free (leak).&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-s-the-point-of-expose-and-what-can-go-wrong-without-it&#34;&gt;What&amp;rsquo;s the point of &lt;code&gt;expose&lt;/code&gt; and what can go wrong without it?&lt;/h4&gt;

&lt;p&gt;Transfer ownership of field from struct to function. Otherwise, we can have
issues like UAFs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void func(NetworkPacket* in ExHeap pk) {
  byte []  in ExHeap d = pkt-&amp;gt;data;
  f(pkt); // if f deletes pkt or if pkt-&amp;gt;data is deleted, etc. we crash below:
  d[32] = 44;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;why-does-singularity-have-channel-contracts-what-are-contracts-and-explain-2-issues-contracts-address-and-how-they-address-them&#34;&gt;Why does Singularity have channel contracts? What are contracts? And, explain 2 issues contracts address and how they address them.&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Homework question&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-is-the-role-of-the-tcell-t-constructor&#34;&gt;What is the role of the &lt;code&gt;TCell&amp;lt;T&amp;gt;&lt;/code&gt; constructor?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Homework question&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>S2E</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/s2e/</link>
      <pubDate>Mon, 14 Nov 2016 01:37:21 -0702</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/s2e/</guid>
      <description>

&lt;p&gt;Author: Brian Johannesmeyer&lt;/p&gt;

&lt;h4 id=&#34;what-conference-was-this-paper-in&#34;&gt;What conference was this paper in?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ASPLOS 2011, where it won best paper&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-types-of-analyses-can-a-developer-do-on-their-code&#34;&gt;What types of analyses can a developer do on their code?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Understand observed behavior&lt;/li&gt;
&lt;li&gt;Characterize future behavior

&lt;ul&gt;
&lt;li&gt;Should be able to do &amp;ldquo;what-if&amp;rdquo; analyses&lt;/li&gt;
&lt;li&gt;However this is difficult because systems are large and complex&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;what-three-properties-does-their-platform-offer&#34;&gt;What three properties does their platform offer?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Efficiently analyze &lt;em&gt;entire families of execution paths&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;i.e. More than one path of execution, and show that properties hold for all
paths in a system&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Maximize &lt;em&gt;realism&lt;/em&gt; by running the analyses in a real software stack

&lt;ul&gt;
&lt;li&gt;Take into account the whole environment surrounding a program&lt;/li&gt;
&lt;li&gt;Most approaches abstract away the environment behind a model, but that may
lose accuracy, and is also labor-intensive&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Ability to &lt;em&gt;directly analyze binaries&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;Access to source code is rarely feasible&lt;/li&gt;
&lt;li&gt;However, is this really a feature? Or are they &lt;em&gt;constrained&lt;/em&gt; to binaries?
This may not work on, e.g. direct JavaScript analysis.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;what-is-symbolic-execution&#34;&gt;What is symbolic execution?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Program analysis to determine what inputs cause each part of a program to execute&lt;/li&gt;
&lt;li&gt;Treat program as superposition of possible execution paths

&lt;ul&gt;
&lt;li&gt;e.g. &lt;code&gt;if(x&amp;gt;0) ... then ... else&lt;/code&gt; treated as superposition of two possible
paths: one for x&amp;gt;0 and one for x&amp;lt;=0.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;For some constraint (e.g. x&amp;gt;0), instead of allowing a variable to take on a
concrete value (e.g. x=5), it takes on a whole set of values (e.g. x:(0,+âˆž))&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-insight-makes-s2e-different-from-normal-symbolic-execution&#34;&gt;What insight makes S2E different from normal symbolic execution?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Often only some families of paths are of interest to developers (e.g. might
not care about analyzing kernel code)&lt;/li&gt;
&lt;li&gt;S2E can selectively choose what to symbolically execute by going back and
forth between multi-path mode (i.e. with symbolic values) and single-path
mode (i.e. with concrete values)&lt;/li&gt;
&lt;li&gt;Also, things can be thrown away in the analysis if we don&amp;rsquo;t care about it&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-are-symbolic-values-converted-to-concrete-values&#34;&gt;How are symbolic values converted to concrete values?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;By simply choosing a value from the symbolic set&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-are-concrete-values-converted-to-symbolic-values&#34;&gt;How are concrete values converted to symbolic values?&lt;/h4&gt;

&lt;p&gt;The symbolic value is constrained to whatever the concrete value was (e.g. x=5,
when originally x&amp;gt;0) to take into account any side effects x=4 may have had.
What can go wrong here?
- You lose a lot of information about the value later on when you convert back
  to a symbolic value, i.e. may overconstrain a value
- It affects completeness&lt;/p&gt;

&lt;h4 id=&#34;what-is-overconstraining&#34;&gt;What is overconstraining?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Constraining a value (whether by soft or hard constraints) so much that it
cannot go down future paths&lt;/li&gt;
&lt;li&gt;What is a soft constraint?

&lt;ul&gt;
&lt;li&gt;Constraint imposed by symbolic/concrete boundary (e.g. x:(0,+âˆž) -&amp;gt; x=5)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is a hard constraint?

&lt;ul&gt;
&lt;li&gt;Constraint imposed by code (e.g. x&amp;gt;0 in &lt;code&gt;if(x&amp;gt;0)...then...else&lt;/code&gt;)
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-is-the-process-of-converting-from-symbolic-to-concrete-values-and-back-processed&#34;&gt;How is the process of converting from symbolic to concrete values and back processed?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;According to an execution consistency model&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;let-s-define-the-parts-of-an-execution-consistency-model&#34;&gt;Letâ€™s define the parts of an execution consistency modelâ€¦&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Analysis spaces

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;System&lt;/strong&gt;: complete software system under analysis, including programs,
libraries, OS, etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unit&lt;/strong&gt;: the part of the system to be analyzed&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Environment&lt;/strong&gt;: the part of the system thatâ€™s not analyzed&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Path types (look at figure on top right of page 4)

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Statically feasible&lt;/strong&gt;: there exists a possible path in the system&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Locally feasible&lt;/strong&gt;: there exists a possible path in the system thatâ€™s
consistent with data-related constraints in the unit&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Globally feasible&lt;/strong&gt;: there exists a possible path in the system thatâ€™s
consistent with all data-related constraints (i.e. in both the unit and the
environment)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Metrics

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Complete&lt;/strong&gt;: every path through the unit thatâ€™s globally feasible will
eventually be discovered by exploration done on that unit&lt;/li&gt;
&lt;li&gt;i.e. all execution paths can be discovered&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consistent&lt;/strong&gt;: every path through the unit has a corresponding globally
feasible path through the system&lt;/li&gt;
&lt;li&gt;i.e. the unit can correctly run on the system&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Why do we care about completeness and consistency?

&lt;ul&gt;
&lt;li&gt;We can do different things with their tradeoffs (see table 1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;strict-consistency&#34;&gt;Strict consistency&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Based on globally feasibility

&lt;ul&gt;
&lt;li&gt;Admits only globally feasible paths, i.e. only allows paths that are
consistent with ALL data-related constraints&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is &lt;em&gt;Strictly Consistent Concrete Execution (SC-CE)&lt;/em&gt;?

&lt;ul&gt;
&lt;li&gt;System is a black box&lt;/li&gt;
&lt;li&gt;Only a single execution path; executed non-symbolically&lt;/li&gt;
&lt;li&gt;Used for:&lt;/li&gt;
&lt;li&gt;Units tests, fuzzing&lt;/li&gt;
&lt;li&gt;Valgrind&lt;/li&gt;
&lt;li&gt;Anything that executes along a single path, generated by user-specified
concrete inputs&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;Doesn&amp;rsquo;t symbolically track anything&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is &lt;em&gt;Strictly Consistent Unit-level Execution (SC-UE)&lt;/em&gt;?

&lt;ul&gt;
&lt;li&gt;Environment treated as a black box&lt;/li&gt;
&lt;li&gt;Exploration engine allowed to gather and use information internal to the unit&lt;/li&gt;
&lt;li&gt;Used by: symbolic and concolic execution tools&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;Symbolic value turned into concrete value when units calls environment&lt;/li&gt;
&lt;li&gt;When environment returns back to unit, the soft constraint it created
becomes a hard constraint&lt;/li&gt;
&lt;li&gt;This hinders completeness&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is &lt;em&gt;Strictly Consistent System-level Execution (SC-SE)&lt;/em&gt;?

&lt;ul&gt;
&lt;li&gt;Nothing is a black box&lt;/li&gt;
&lt;li&gt;Exploration engine allowed to gather and use information about the entire
system&lt;/li&gt;
&lt;li&gt;Limited by: path explosion problem&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;Symbolic values everywhere&lt;/li&gt;
&lt;li&gt;Path explosion

&lt;ul&gt;
&lt;li&gt;Can use heuristics to prioritize path exploration,&lt;/li&gt;
&lt;li&gt;Or employ incremental symbolic execution
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;local-consistency-lc&#34;&gt;Local Consistency (LC)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Avoids exploring all paths in the environment&lt;/li&gt;
&lt;li&gt;Replaces results of calls to the environment with the symbolic values that
represent possible valid results

&lt;ul&gt;
&lt;li&gt;e.g. &lt;code&gt;write(fd, buf,count)&lt;/code&gt; can return any integer between -1 and count&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Allows for inconsistencies in the environment while keeping the state of the
unit internally consistent&lt;/li&gt;
&lt;li&gt;No false positives because the internal state is consistent&lt;/li&gt;
&lt;li&gt;Implementation

&lt;ul&gt;
&lt;li&gt;At environment-boundary, concrete output value is turned into a symbolic
value based on the functionâ€™s specification&lt;/li&gt;
&lt;li&gt;However, if symbolic data is written to the environment, it may become
inconsistent&lt;/li&gt;
&lt;li&gt;If a branch in the environment depends on symbolic data, the execution
path must be aborted
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;relaxed-consistency&#34;&gt;Relaxed consistency&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Disadvantages

&lt;ul&gt;
&lt;li&gt;Inconsistent in the general case&lt;/li&gt;
&lt;li&gt;Internal state of the unit may be inconsistent, producing false positives&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Advantage: Performance&lt;/li&gt;
&lt;li&gt;What is &lt;em&gt;Overapproximate Consistency (RC-OC)&lt;/em&gt;?

&lt;ul&gt;
&lt;li&gt;Path exploration can follow paths through the unit while completely
ignoring the constraints&lt;/li&gt;
&lt;li&gt;E.g. call to write() would not bound the return value&lt;/li&gt;
&lt;li&gt;Thus, violates the specification of the write system call&lt;/li&gt;
&lt;li&gt;Used for: reverse engineering&lt;/li&gt;
&lt;li&gt;Why is it used for reverse engineering?&lt;/li&gt;
&lt;li&gt;See 6.1.2 - They fake the hardware in order to understand what the
drivers are doing&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;At unit/environment boundaries, converts concrete values into
unconstrained symbolic values&lt;/li&gt;
&lt;li&gt;E.g. All possible values that write() could return, rather values it
should return&lt;/li&gt;
&lt;li&gt;Gives completeness at the expense of consistency&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What is &lt;em&gt;CFG Consistency (RC-CC)&lt;/em&gt;?

&lt;ul&gt;
&lt;li&gt;Exploration engine allowed to change any part of the system state as long
as the explored paths correspond to paths in the unitâ€™s inter-procedural
CFG&lt;/li&gt;
&lt;li&gt;Used for: disassembling obfuscated and/or encrypted code&lt;/li&gt;
&lt;li&gt;Implementation&lt;/li&gt;
&lt;li&gt;Pursues all outcomes of every branch, regardless of path constraints&lt;/li&gt;
&lt;li&gt;Thus, follows all edges in the unit&amp;rsquo;s inter-procedural CFG&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;s2e-api&#34;&gt;S2E API&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Tables 2 and 3 give the best overview of what core events can be used to
develop analysis tools, and an idea of the interface to the &lt;em&gt;ExecState&lt;/em&gt; object.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;How are bugs that may result from slower system execution in symbolic mode
mitigated?

&lt;ul&gt;
&lt;li&gt;The virtual clock is slowed down when symbolically executing a state&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Definitions

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Virtualization&lt;/strong&gt;: creating a software-based (or virtual) representation
of something rather than a physical one&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dynamic binary translation&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;Emulation of one instruction set by another through translation of binary
code (e.g. ARM -&amp;gt; x86)&lt;/li&gt;
&lt;li&gt;S2E turns blocks of guest code into corresponding host code&lt;/li&gt;
&lt;li&gt;Dynamic means it happens as it executes

&lt;ul&gt;
&lt;li&gt;Translates code as it is explored&lt;/li&gt;
&lt;li&gt;Typically one basic block is translated at a time then cached&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Copy-on-write&lt;/strong&gt;: improves performance by only copying an object when the
copy or the original is written to&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;evaluation&#34;&gt;Evaluation&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;What 3 questions did they try to answer and how did they go about evaluating them?

&lt;ol&gt;
&lt;li&gt;Is S2E a &lt;em&gt;general&lt;/em&gt; platform for building tools?&lt;/li&gt;
&lt;li&gt;Showed that S2E can be used to build 3 very different tools (section 6.1).&lt;/li&gt;
&lt;li&gt;Does S2E have reasonable &lt;em&gt;performance&lt;/em&gt;?&lt;/li&gt;
&lt;li&gt;Discussed its overhead in both concrete mode (~6x) and symbolic mode
(~78x) and ways to reduce it (section 6.2).&lt;/li&gt;
&lt;li&gt;What are the &lt;em&gt;tradeoffs&lt;/em&gt; between choosing different execution consistency
models?&lt;/li&gt;
&lt;li&gt;Gave figures showing code coverage, memory usage, and constraint solving
time based on which consistency model was used (section 6.3).&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;What is Table 4 trying to convey? Do it do so successfully?

&lt;ul&gt;
&lt;li&gt;It is trying to convey the usability of S2E: that it is straightforward to
instrument and create custom analysis tools. However there are a few things
that are wrong with their approach:&lt;/li&gt;
&lt;li&gt;First, they built DDT and RevNIC previously, so they already understand
the ins and outs of developing these types of analysis tools. Thus, their
development time should naturally be dramatically shorter because they&amp;rsquo;ve
already implemented a similar system. This confounds their development
time results.&lt;/li&gt;
&lt;li&gt;In addition, not many details are given for their calculation of
&amp;ldquo;person-hours&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Also, it mentions in Table 4&amp;rsquo;s caption that &amp;ldquo;10 KLOC of offline analysis
code is reused in [REV+]&amp;ldquo;. However, that element of the table does not
have those 10 KLOC added to it. If those 10 KLOC count against the
previous implementation (i.e. 57,000 LOC), it should count against the
new implementation too (i.e. 10,580 LOC instead of 580 LOC).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Even after going through the tradeoffs of different consistency models in
section 6.2, I don&amp;rsquo;t think it would be immediately clear to developers which
model they should use.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Microchex</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/uchex/</link>
      <pubDate>Mon, 07 Nov 2016 01:37:21 -0702</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/uchex/</guid>
      <description>

&lt;p&gt;Author: Gary Soeller&lt;/p&gt;

&lt;h4 id=&#34;what-problem-does-uchex-address&#34;&gt;What problem does uchex address?&lt;/h4&gt;

&lt;p&gt;Static bug checkers require a full compiler front end (lexer and parser) to build
a complete grammar. This often requires an enormous engineering effort and is
not easy for developers to write their own static checker.&lt;/p&gt;

&lt;h4 id=&#34;what-is-uchex&#34;&gt;What is uchex?&lt;/h4&gt;

&lt;p&gt;uchex is a framework for easily writing language agnostic static bug checkers.&lt;/p&gt;

&lt;h4 id=&#34;how-does-uchex-solve-the-problem-addressed&#34;&gt;How does uchex solve the problem addressed?&lt;/h4&gt;

&lt;p&gt;uchex solves the problem by using a &lt;em&gt;micro-grammar&lt;/em&gt;: a grammar which contains a
subset of the grammar being parsed. uchex allows developers to write a checker
for a subset of the grammar allowing them the ability to easily write a
checker.  A major benefit of uchex checkers is that they are language agnostic.
Furthermore, micro-grammars can also be language agnostic since they only parse
a small fraction of grammars. This allows code to be reused easily.&lt;/p&gt;

&lt;h4 id=&#34;what-are-the-properties-of-a-micro-grammar&#34;&gt;What are the properties of a micro-grammar?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;The original grammar is a subset of the micro-grammar.&lt;/li&gt;
&lt;li&gt;The original grammar and micro-grammar have the same structure.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Why are these two properties important?&lt;/p&gt;

&lt;h4 id=&#34;how-does-the-uchex-parser-differ-from-a-traditional-parser&#34;&gt;How does the uchex parser differ from a traditional parser?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Sliding window: This allows the parser to continue when it does not
recognize a token.&lt;/li&gt;
&lt;li&gt;Wildcard: Allows the parser to match anything.&lt;/li&gt;
&lt;li&gt;Commit points: Allows the parser to stop sliding forward once an important
token is reached for badly written micro-grammars.&lt;/li&gt;
&lt;li&gt;Compositional parsers: Allows parsers to be chained together. (Though
parsec-based parsers often have this property.)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;what-is-a-belief-style-checker&#34;&gt;What is a belief-style checker?&lt;/h4&gt;

&lt;p&gt;A type of checker that makes assumptions about the code. While traversing the
code, if the checker can contradict an assumption, then there is an error.&lt;/p&gt;

&lt;p&gt;All of the example checkers they present use belief-style, but they are not
necessarily limited to this.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-algorithm-for-the-null-pointer-checker&#34;&gt;What is the algorithm for the null pointer checker?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;When a pointer is dereferenced, it is added to a &amp;ldquo;not null&amp;rdquo; set. The &amp;ldquo;not
null&amp;rdquo; set is the set of &amp;ldquo;beliefs&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Whenever a not null check is made, the pointer is looked up in the &amp;ldquo;not
null&amp;rdquo; set.&lt;/li&gt;
&lt;li&gt;If pointer is set, a belief is contradicted indicating that there is an
error.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The null pointer checker uses forward data flow analysis. This allows the
checker to know information about the past. Other checkers use backward data
flow analysis which gives the checker information about the future.&lt;/p&gt;

&lt;h4 id=&#34;what-type-of-bugs-can-uchex-catch&#34;&gt;What type of bugs can uchex catch?&lt;/h4&gt;

&lt;p&gt;Intra-procedural. This is the most simple type of bug because it requires no
context outside of the function.&lt;/p&gt;

&lt;h4 id=&#34;what-types-of-bugs-does-uchex-not-catch&#34;&gt;What types of bugs does uchex not catch?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Those that require inter-procedural analysis.  What are inter procedural
checkers and what can these catch that uchex can&amp;rsquo;t?&lt;/li&gt;
&lt;li&gt;Those that require alias tracking. What is alias tracking and why is this
hard to support?&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;what-type-of-grammar-is-uchex-able-to-parse-and-why-is-this-important&#34;&gt;What type of grammar is uchex able to parse and why is this important?&lt;/h4&gt;

&lt;p&gt;uchex can parse LL(k) grammars. There are limitations with parsers so it is
important to know which type of parser is being used. One limitation of LL(k) is
that left-recursion can not be parsed. Therefore, the developer must eliminate
it from the grammar.&lt;/p&gt;

&lt;h4 id=&#34;how-is-uchex-evaluated&#34;&gt;How is uchex evaluated?&lt;/h4&gt;

&lt;p&gt;uchex is evaluated against an undisclosed industrial static checker (called
&lt;em&gt;SystemX&lt;/em&gt; in the paper). Both checkers are run on the same codebases and the
results are compared by counting the number and overlap of bugs found. It is
important to note that uchex and SystemX can use each others results as ground
truth. This way they can be used in conjunction to improve each other.&lt;/p&gt;

&lt;p&gt;uchex is also evaluated to demonstrate simplicity and ease of developing new
checkers. The only metric used is lines of code. This does not say much so it
should be taken with a grain of salt.&lt;/p&gt;

&lt;p&gt;Deian, on last point: if you&amp;rsquo;ve written checkers you&amp;rsquo;ll find that LOC is pretty
reasonable. Managing giant ASTs and state in existing frameworks is super hard.
Moreover, I think for this we can partially appeal to authority: Dawson has
done work on checkers for decades.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>COWL</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/cowl/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0709</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/cowl/</guid>
      <description>

&lt;p&gt;Author: Rohit Jha&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-motivation-behind-cowl&#34;&gt;What is the motivation behind COWL?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Flexibility vs privacy&lt;/li&gt;
&lt;li&gt;MAC-based confinement better than DAC&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;at-a-high-level-what-does-cowl-do&#34;&gt;At a high-level, what does COWL do?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;COWL is a robust JavaScript confinement system for modern web browsers.&lt;/li&gt;
&lt;li&gt;COWL introduces label-based MAC to browsing contexts (pages, iframes, etc.)
in a way that is fully backward-compatible with legacy web content&lt;/li&gt;
&lt;li&gt;Prevents information leaks&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-the-design-requirements-for-cowl&#34;&gt;What are the design requirements for COWL?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;MAC with:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Symmetric confinement: two mutually distrusting scripts can each confine
the otherâ€™s use of data they send one another&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hierarchical confinement: allows any developer to confine untrusted code,
and confinement can be nested to arbitrary depths&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Delegation: allows a developer explicitly to confer the privileges of one
execution context on a separate execution context&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;

&lt;h4 id=&#34;what-are-some-browser-security-policies-and-concepts-explained-in-the-paper&#34;&gt;What are some browser security policies and concepts explained in the paper?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Browsing contexts&lt;/li&gt;
&lt;li&gt;Same-Origin Policy (SOP): how does SOP not prevent data from being disclosed
to foreign origins?&lt;/li&gt;
&lt;li&gt;Content Security Policy (CSP): what are the limitations of CSP?&lt;/li&gt;
&lt;li&gt;postMessage and Cross-Origin Resource Sharing (CORS): what is the difference
between these two?&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-the-motivating-web-applications-explained-in-the-paper&#34;&gt;What are the motivating web applications explained in the paper?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Password strength checker:

&lt;ul&gt;
&lt;li&gt;What are the possible security risks here?&lt;/li&gt;
&lt;li&gt;How does COWL add security to a third-party password checker?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Encrypted document editor&lt;/li&gt;
&lt;li&gt;Third-party mashup&lt;/li&gt;
&lt;li&gt;Untrusted third-party library: How does COWL mitigate reuse risks?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cowl-confinement-system&#34;&gt;COWL Confinement System&lt;/h2&gt;

&lt;h4 id=&#34;cowl-augments-browsers-with-three-primitives-what-are-these&#34;&gt;COWL augments browsers with three primitives. What are these?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Labeled browsing contexts&lt;/li&gt;
&lt;li&gt;Labeled communication&lt;/li&gt;
&lt;li&gt;Privileges&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;structure-of-a-label&#34;&gt;Structure of a label&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;(secrecy formula, integrity formula)

&lt;ul&gt;
&lt;li&gt;Secrecy: which origins can read a contextâ€™s data&lt;/li&gt;
&lt;li&gt;Integrity: which origins can write it&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-does-cowl-enforce-label-policies&#34;&gt;How does COWL enforce label policies?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Allowing a context to only communicate with other contexts or servers whose
labels are at least as restricting&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;can-a-script-leak-information-through-a-newly-created-context-how&#34;&gt;Can a script leak information through a newly created context? How?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Newly created context implicitly inherits current label of parent&lt;/li&gt;
&lt;li&gt;The parent may specify a more restrictive label for its child&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-the-two-types-of-contexts-cowl-applications-can-create&#34;&gt;What are the two types of contexts COWL applications can create?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Standard contexts: pages, iframes, workers, etc.&lt;/li&gt;
&lt;li&gt;Labeled contexts in the form of lightweight labeled workers (LWorkers)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-lworkers-and-why-are-they-helpful-why-not-use-normal-workers&#34;&gt;What are LWorkers and why are they helpful? Why not use normal workers?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Lightweight labeled workers which execute in the same thread as their parent&lt;/li&gt;
&lt;li&gt;Share the event loop with their parent&lt;/li&gt;
&lt;li&gt;Have access to COWL API, XHR constructor and can communicate with parent&lt;/li&gt;
&lt;li&gt;Parent can give read/write DOM access to child since they are in the same
thread&lt;/li&gt;
&lt;li&gt;LWorkers simplify the isolation and confinement of scripts&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-does-cowl-support-labeled-communication&#34;&gt;How does COWL support labeled communication?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Labeled Blob messages (intra-browser)&lt;/li&gt;
&lt;li&gt;Labeled XHR messages (browser-server)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-labeled-blobs&#34;&gt;What are labeled Blobs?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Encapsulation of an inter-context message (payload - serializable and
immutable Blob object) with the label&lt;/li&gt;
&lt;li&gt;This label is at least as restrictive as the sending contextâ€™s current label&lt;/li&gt;
&lt;li&gt;Receiving context can access label - and can access the message only after
itâ€™s label is raised as needed&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;why-are-labeled-blobs-useful&#34;&gt;Why are labeled Blobs useful?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Sender can impose confinement on the receiver by labeling a message&lt;/li&gt;
&lt;li&gt;Receiver can delay reading the message content until they are done
communicating with origins not allowed to read the data&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-labeled-xhr-messages&#34;&gt;What are labeled XHR messages?&lt;/h4&gt;

&lt;p&gt;Similar to labeled Blobs but for browser-server communication&lt;/p&gt;

&lt;h4 id=&#34;when-may-a-context-need-to-declassify-data&#34;&gt;When may a context need to declassify data?&lt;/h4&gt;

&lt;p&gt;It may need to send encrypted data from one origin to a third-party origin&lt;/p&gt;

&lt;h4 id=&#34;how-does-cowl-s-privilege-primitive-support-declassification&#34;&gt;How does COWLâ€™s Privilege primitive support declassification?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;A context may hold one or more privileges, each with respect to some origin.&lt;/li&gt;
&lt;li&gt;Possession of a privilege for an origin by a context denotes trust that the
scripts that execute within that context will not compromise the secrecy of
data from that origin&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;applications&#34;&gt;Applications&lt;/h2&gt;

&lt;h4 id=&#34;password-checker-similar-to-encrypted-document-editor-application&#34;&gt;Password checker similar to encrypted document editor application&lt;/h4&gt;

&lt;h4 id=&#34;how-does-the-encrypted-document-editor-open-and-save-an-encrypted-doc&#34;&gt;How does the encrypted document editor open and save an encrypted doc?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;gdoc.com downloads encrypted doc from Googleâ€™s servers&lt;/li&gt;
&lt;li&gt;gdoc.com opens an iframe to eff.org with label public and downloaded private
key&lt;/li&gt;
&lt;li&gt;gdoc.com sends the encrypted doc as labeled Blob with label (gdoc.com)&lt;/li&gt;
&lt;li&gt;The iframe unlabels the Blob and raises its label to decrypt the doc&lt;/li&gt;
&lt;li&gt;Pass the decrypted doc to the iframe implementing the editor&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;Reverse for saving a doc&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-does-cowl-support-third-party-mashups&#34;&gt;How does COWL support third-party mashups?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Mashup sends labeled XHRs to both Amazon and Chase to get purchase history
and bank statement as labeled Blobs&lt;/li&gt;
&lt;li&gt;Once all the info is received, mashup unlabels the responses and raises itâ€™s
label COWL cannot prevent a malicious mashup from leaking data via covert
channels&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;how-does-cowl-confine-an-untrusted-jquery-library&#34;&gt;How does COWL confine an untrusted jQuery library?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;page generates a fresh origin unq0 and spawns a DOM worker&lt;/li&gt;
&lt;li&gt;main context drops its privileges and raises its label to (unq0)&lt;/li&gt;
&lt;li&gt;the trusted worker downloads jQuery&lt;/li&gt;
&lt;li&gt;The trusted worker injects the script content into the main contextâ€™s DOM&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The main context becomes untrusted, but is fully confined. The spawned DOM
worker can modify the DOM of the main context and communicate on the web -
acting as a firewall.&lt;/p&gt;

&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;

&lt;h3 id=&#34;what-are-the-challenges-to-implementing-cowl-for-chromium&#34;&gt;What are the challenges to implementing COWL for Chromium?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Chromium architecture does not have cross-compartment wrappers so the DOM
binding code was modified to insert label checks&lt;/li&gt;
&lt;li&gt;Without wrappers, shared references cannot be efficiently revoked&lt;/li&gt;
&lt;li&gt;The current Chromium API allows senders to disallow labeling Blobs if any
children were created before starting confinement mode&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;evaluation&#34;&gt;Evaluation&lt;/h2&gt;

&lt;h4 id=&#34;what-is-the-evaluation-strategy-used&#34;&gt;What is the evaluation strategy used?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Measuring cost of new primitives and impact on legacy websites that donâ€™t use
COWL&lt;/li&gt;
&lt;li&gt;Benchmarks:

&lt;ul&gt;
&lt;li&gt;Microbenchmarks of API functions&lt;/li&gt;
&lt;li&gt;End-to-end benchmarks of example applications&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Applications accessed from a Node server over loopback&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-do-you-think-about-cowl-s-performance-for-microbenchmarks-and-end-to-end-benchmarks&#34;&gt;What do you think about COWLâ€™s performance for microbenchmarks and end-to-end benchmarks?&lt;/h4&gt;

&lt;h2 id=&#34;discussion&#34;&gt;Discussion&lt;/h2&gt;

&lt;h4 id=&#34;what-are-the-benefits-and-risks-of-having-users-override-cors&#34;&gt;What are the benefits and risks of having users override CORS?&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>Chrome extension system</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/chrome-extension-system/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0708</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/chrome-extension-system/</guid>
      <description>

&lt;p&gt;Author: Ariana Mirian&lt;/p&gt;

&lt;h4 id=&#34;background&#34;&gt;Background&lt;/h4&gt;

&lt;p&gt;Presented in 2010, at NDSS (Network and Distributed System Security).&lt;/p&gt;

&lt;p&gt;The following people were on the paper:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Adam Barth: (one of first people working on) Security at Chrome&lt;/li&gt;
&lt;li&gt;Adrienne Porter Felt: Usable Security at Chrome&lt;/li&gt;
&lt;li&gt;Prateek Saxena: Prof at National University of Singapore&lt;/li&gt;
&lt;li&gt;Aaron Boodman: Helped build Chrome, now at Startup&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;They were all at some point invested in Google (or still are), and had a vested
interest in making a system that worked and was effective.&lt;/p&gt;

&lt;p&gt;To review, a browser extension is a third party software that extends the
functionality of a web browser.&lt;/p&gt;

&lt;h4 id=&#34;problem&#34;&gt;Problem&lt;/h4&gt;

&lt;p&gt;The question that the authors were trying to answer is if browser extensions
require such a high level of privilege.&lt;/p&gt;

&lt;p&gt;In order to answer this, the authors analyzed Firefox Browser system and
implement an alternate extension system with the Chrome Extension System.&lt;/p&gt;

&lt;p&gt;One could say that the Firefox model at the time was silly and had lacked any
regard for security. However, it is important to remember that extensions were
meant to supplement a user&amp;rsquo;s experience and, before this point, the use case
for extensions wasn&amp;rsquo;t clear. Firefox had no idea what to expect, while the
authors of this paper benefited from hindsight.&lt;/p&gt;

&lt;p&gt;The threat model is &lt;em&gt;benign but buggy&lt;/em&gt; extensions: a malicious attacker could
corrupt the extension and usurp its privileges.&lt;/p&gt;

&lt;h4 id=&#34;evolution-of-firefox&#34;&gt;Evolution of Firefox&lt;/h4&gt;

&lt;p&gt;The paper argues that the underlying issue of the four potential (out of many)
attacks is that Firefox extensions interact directly with untrusted content
while possessing a high level of privilege &amp;mdash; by rethinking the architecture
they aren&amp;rsquo;t just fixing one problem, they are addressing most of them.&lt;/p&gt;

&lt;p&gt;While they argue that there was no way to automate the extension analysis, there
might have been a way to perform a program analysis to look at how the APIs are
used. On this note, while their paper did well with only 25 extensions from the
Firefox Extension system, it could have benefited from a larger analysis to
provide a better picture of how the average extension dealt with privileges.&lt;/p&gt;

&lt;p&gt;Out of the 25 extensions that they analyzed, 19 had &amp;lsquo;critical&amp;rsquo; privileges,
meaning that they could run arbitrary code on the user&amp;rsquo;s system, while only 3
required critical privileges. This is an example of a privilege gap.&lt;/p&gt;

&lt;p&gt;The paper then goes into discussing a security lattice that they used to
analyze the Firefox extension API. They show that there is a considerable
number of escalation points that need to be addressed, and that the separation
of privileges is not necessarily as easy as it seems. APIs need to be designed
from the start with privileges in mind.&lt;/p&gt;

&lt;p&gt;From this analysis, they propose building a new system following the principle
of least privilege, privilege separation, and strong isolation.&lt;/p&gt;

&lt;h4 id=&#34;google-chrome-extension-system&#34;&gt;Google Chrome Extension System&lt;/h4&gt;

&lt;p&gt;The Google chrome extension system implements privilege separation and isolation
mechanisms.&lt;/p&gt;

&lt;h5 id=&#34;why-did-they-need-both&#34;&gt;Why did they need both?&lt;/h5&gt;

&lt;p&gt;The privilege separation was broken into three differed hierarchies: &lt;em&gt;content
scripts&lt;/em&gt;, &lt;em&gt;extension core&lt;/em&gt;, and &lt;em&gt;native binary&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Content scripts are JavaScript scripts that allow extensions to directly
interact with the untrusted web content (DOM) &amp;mdash; since they have the largest
attack surface, they do not have any direct access to privileged APIs. They can
only communicate with the extension core via message passing.&lt;/p&gt;

&lt;p&gt;Extension cores have access to privileged APIs (which, for example, allow them
to create new tabs) as declared in the extension&amp;rsquo;s manifest and approved by the
user at install time.  The core does not interact with untrusted web content
directly; it can only communicate with untrusted context via the content script
or using an XMLHTTPRequest.&lt;/p&gt;

&lt;p&gt;Finally, the native binary can run arbitrary code or access arbitrary files.&lt;/p&gt;

&lt;p&gt;The isolation mechanisms are similarly split up into separate parts.
- Origins are used to ensure isolation between different extension cores. This,
  for example, ensures that one extension cannot mess with another&amp;rsquo;s
  &lt;code&gt;localStorage&lt;/code&gt;.
- Extension cores and native binaries are run in different OS processes. This
  ensures isolation between themselves and content.
- Content scripts run in &lt;em&gt;isolated worlds&lt;/em&gt;. They have a separate JavaScript
  heap and separate access to the DOM of the untrusted web page they run in.
  This ensures that content scripts are isolated from the untrusted content and
  other extensions (under the buggy but benign model).&lt;/p&gt;

&lt;h4 id=&#34;discussion&#34;&gt;Discussion&lt;/h4&gt;

&lt;p&gt;In order to evaluate their system, they measured page latency and DOM access
time &amp;mdash; both had increases, respectively 0.8ms and 33.3%. What was missing was
a lack of a user study to understand the implications of their system. In the
end, the hindsight from the Firefox extension system helped them a lot, because
they were able to see a (small) sample of how users use extensions and what
could go wrong.&lt;/p&gt;

&lt;p&gt;Today, the paper could be improved in various ways. You could look at more
extensions or determine more concretely what the APIs should look like, and,
given yet more hindsight, consider a more realistic attacker model.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NaCl</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/nacl/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0706</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/nacl/</guid>
      <description>

&lt;p&gt;Author: Shravan Narayan&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-high-level-goal&#34;&gt;What is the high level goal?&lt;/h4&gt;

&lt;p&gt;To be able to run native binaries securely, while incurring as little overhead
as possible to ensure the safety of the system.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-high-level-strategy&#34;&gt;What is the high level strategy?&lt;/h4&gt;

&lt;p&gt;This is done by ensuring that any faults or bug are isolated to the module, i.e.
the bug cannot be used to take over the entire system.&lt;/p&gt;

&lt;h4 id=&#34;why-do-you-want-native-code&#34;&gt;Why do you want native code?&lt;/h4&gt;

&lt;p&gt;Native code has the benefit of running on bare metal, i.e. there are no layers
of interpreters or virtual machines that are needed for them to operate. Thus
the performance of native code is significantly better than interpreted code of
virtual machine code.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-threat-model&#34;&gt;What is the threat model?&lt;/h4&gt;

&lt;p&gt;The threat model is one of where a malicious website creator may use native
binaries to take over your computer, or a malicious entity could try to take
over the computer by abusing a bug in one of the native binaries that are
currently loaded on to the browser by a website.&lt;/p&gt;

&lt;h4 id=&#34;what-are-the-inner-and-outer-sandboxes&#34;&gt;What are the inner and outer sandboxes?&lt;/h4&gt;

&lt;p&gt;NaCl implements its security by running native binaries on 2 layers of
sandboxes. The inner layer is a sandbox that implements fault isolation - i.e.
any bug in the program is isolated such that it cannot have an effect on the
rest on the system. The outer sandbox is an added safety mechanism - this is a
layer that restricts system calls to only a subset of allowed ones.  In the
Linux Chromium version, this is currently implemented via
&lt;a href=&#34;https://en.wikipedia.org/wiki/Seccomp&#34;&gt;seccomp-bpf&lt;/a&gt; which allow this sort of
system call filtering.&lt;/p&gt;

&lt;h4 id=&#34;how-is-the-software-isolation-enforced-in-the-inner-sandbox-in-nacl&#34;&gt;How is the software isolation enforced in the inner sandbox in NaCl?&lt;/h4&gt;

&lt;p&gt;Software isolation is enforced with the help of the x86 memory segmentation
features and an instruction verifier.  Segments ensure that the program cannot
read/write to parts of memory outside the untrusted code&amp;rsquo;s bounds. The
instruction verifier ensures that only safe (e.g., no memory jumps),
properly-aligned instructions are allowed. Bit masks are used to ensure that
jump instructions cannot jump to the middle of existing instructions.&lt;/p&gt;

&lt;h4 id=&#34;what-are-some-of-the-complications-with-parsing-x86-code-what-steps-are-taken-to-mitigate-these-complications&#34;&gt;What are some of the complications with parsing x86 code? What steps are taken to mitigate these complications?&lt;/h4&gt;

&lt;p&gt;x86 code has variable sized instructions. Even a particular instruction may
have representations in multiple lengths. This may be lead to non-aligned
overlapping instructions. Another challenge is self modifying code - which is
used in applications such as JIT code generation etc.&lt;/p&gt;

&lt;p&gt;To reduce the complexity, all instructions are aligned at word boundaries (aka
32 bit aligned), self modifying code is not allowed and all jump instructions
are forced to jump to word boundaries.&lt;/p&gt;

&lt;h4 id=&#34;what-are-examples-of-instructions-or-other-operations-not-allowed-by-nacl&#34;&gt;What are examples of instructions or other operations not allowed by NaCl?&lt;/h4&gt;

&lt;p&gt;NaCl blocks any instructions that allow changing the segment state, system
calls, interrupts and return aka long jump instructions (a modified long jump
called NaCl jump which is an and instruction followed jump is allowed. The and
instruction ensures that the jump instruction stays at word boundaries.)&lt;/p&gt;

&lt;h4 id=&#34;what-happens-if-we-don-t-mask-jumps-i-e-what-happens-if-we-allow-regular-jump-or-return-instructions-instead-of-nacl-jump&#34;&gt;What happens if we don&amp;rsquo;t mask jumps, i.e. what happens if we allow regular jump or return instructions instead of NaCl jump?&lt;/h4&gt;

&lt;p&gt;If we don&amp;rsquo;t mask jumps, a program vulnerability could allow the execution of
instructions that are not allowed such as segment instructions, by creatively
jumping in the middle of an existing instruction. If the location for the jump
is picked carefully, the middle of a target instruction could be read by the
processor as an instruction which we want to block.&lt;/p&gt;

&lt;h4 id=&#34;what-happens-if-we-don-t-use-segmented-memory&#34;&gt;What happens if we don&amp;rsquo;t use segmented memory?&lt;/h4&gt;

&lt;p&gt;Without segmented memory, there is nothing stopping a jump instruction to jump
to an arbitrary location outside the segment (e.g., to parts of the trusted
reference monitor). Thus we would need some other mechanism to enforce the
program memory isolation. One such technique is used in one of the papers
referred to in the NaCl paper - PittsField. The PittsField paper enforces this
isolation without segments by applying a bit mask on the most significant bits
before every jump to ensure the jump is confined to a part of the memory.&lt;/p&gt;

&lt;h4 id=&#34;what-are-the-various-components-included-in-a-nacl-applications-runtime&#34;&gt;What are the various components included in a NaCl applications runtime?&lt;/h4&gt;

&lt;p&gt;Each sandboxed application is run in an environment with the following pieces
- an inter module communications service: which allows communication between
  components, components and the browser via messages, shared memory segments
  and synchronization objects
- service runtime: which allows memory management APIs, thread creation interfaces etc.&lt;/p&gt;

&lt;h4 id=&#34;why-does-nacl-have-srpc-and-npapi&#34;&gt;Why does NaCl have SRPC and NPAPI?&lt;/h4&gt;

&lt;p&gt;SRPC is a protocol that allows communication between NaCl modules as well as
the JavaScript in the browser by declaring the procedural interface with basic
data types. NPAPI (Netscape Plugin API) is a protocol which is used to interact
with DOM, JS objects directly, etc. NPAPI is actually quite an old protocol
that is no longer used by NaCl. They have replaced this with a new protocol
called Pepper with the goal of better platform portability and security.&lt;/p&gt;

&lt;h4 id=&#34;how-is-the-isolation-provided-by-nacl-thwart-a-simple-buffer-overflow-vulnerability-that-gives-arbitrary-code-execution&#34;&gt;How is the isolation provided by NaCl thwart a simple buffer overflow vulnerability that gives arbitrary code execution?&lt;/h4&gt;

&lt;p&gt;NaCl does not prevent the buffer overflow, however, the buffer is stored in a
separate data segment. So, a buffer overflow cannot be used to overwrite the
return pointer on the stack. Also, this segment is separated from the rest of
the call stack and the memory page containing the data segment is marked as
no-execute and so cannot be executed.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-validator-what-are-the-use-cases-and-constraints&#34;&gt;What is the validator? What are the use cases and constraints?&lt;/h4&gt;

&lt;p&gt;The validator is a program that is used prior to loading a NaCl binary. This
program validates that a given NaCl binary confirms to all the rules about
using only allowed and word aligned instructions, masking jump locations, etc.
The validator thus needs to be able to efficiently parse x86 instructions - the
word alignment restriction as well as a small subset of allowed instructions
makes this simpler. As the validator is used just before loading the binary, it
is required that this operate with minimum overhead, so as to not introduce any
latency.&lt;/p&gt;

&lt;h4 id=&#34;the-paper-talks-about-exceptions-what-are-they-how-are-they-supported&#34;&gt;The paper talks about exceptions. What are they? How are they supported?&lt;/h4&gt;

&lt;p&gt;There are 2 types of exceptions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hardware exceptions: interrupts delivered by the OS such as floating point exceptions&lt;/li&gt;
&lt;li&gt;Software exceptions: the regular exceptions encountered by the language which
are handled by the try catch syntax.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hardware exceptions are not supported and will cause the NaCl program to be
terminated. This is because segmented memory modes were not very well supported
by the OS - i.e. the OS doesn&amp;rsquo;t have a mechanism to deliver exceptions to
processed which have modified the stack segment register.  Software exceptions
function as expected.&lt;/p&gt;

&lt;h4 id=&#34;are-system-calls-allowed-in-nacl-describe-the-mechanism-used-to-enable-block-this&#34;&gt;Are system calls allowed in NaCl? Describe the mechanism used to enable/block this?&lt;/h4&gt;

&lt;p&gt;System calls are not directly allowed. However NaCl provides a mediated
approach to some functions, including system calls, with the help of trampolines
and springboards. These mechanisms are implemented as part of the Service
Runtime. Trampolines are trusted code that removes the segment restrictions,
and calls into unsandboxed code. This code executes and returns via the
springboard. The springboard resets these stack restrictions. Note that the
springboard code is also used as to provide the threading interface for a NaCl
binary - however this cannot be invoked directly by the sanboxed NaCl app.&lt;/p&gt;

&lt;h4 id=&#34;the-paper-describes-a-particular-memory-layout-for-nacl-binaries-what-are-the-benefits&#34;&gt;The paper describes a particular memory layout for NaCl binaries? What are the benefits?&lt;/h4&gt;

&lt;p&gt;The memory layout starts with one page (4kb) of unallocated space - this is
used to detect null pointer exceptions as any reference to this memory will
cause a page fault. The next 60 KB is used by the service runtime to load the
trusted trampoline and springboard code. Trampolines can only contain function
whose entries are at word boundaries as they need to be callable by the NaCl
binary. The springboard should not be called directly by the NaCl binary as it
manipulates segment information and so have entries that are not word aligned.&lt;/p&gt;

&lt;h4 id=&#34;what-were-some-of-the-modifications-required-to-the-compilers-to-generate-nacl-binaries&#34;&gt;What were some of the modifications required to the compilers to generate NaCl binaries?&lt;/h4&gt;

&lt;p&gt;GCC was modified to ensure&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;function entries were only at word boundaries&lt;/li&gt;
&lt;li&gt;branch targets are 32 bit aligned&lt;/li&gt;
&lt;li&gt;to use nacljump for indirect transfers&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-is-the-overhead-of-a-nacl-binary&#34;&gt;What is the overhead of a NaCl binary?&lt;/h4&gt;

&lt;p&gt;Several benchmarks were run to estimate overhead - the average overhead seems
to be about 5%. Benchmarks included SPEC2000, graphics tests, video decoding,
physics simulations, and games. The equally important metric was the latency
overhead of the NaCl verifier, which was measured to be on the order of
30MB/second (small compared to download time).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Verena</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/verena/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0705</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/verena/</guid>
      <description>

&lt;p&gt;Author: Zhaomo Yang&lt;/p&gt;

&lt;h4 id=&#34;the-foundation-that-verena-relies-on&#34;&gt;The foundation that Verena relies on.&lt;/h4&gt;

&lt;p&gt;Verena is based on some ideas from Mylar, which is briefly mentioned in III-A.
Specifically, the authors assume:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A web page that the app client receives consists of two separate parts: a
static web page (code) and data;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The static page is signed by the developer. The signature is verified by the
Verena browser extension, which has the developer&amp;rsquo;s public key.  From now on,
let&amp;rsquo;s assume that the web page has verified.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;the-architecture-of-verena&#34;&gt;The architecture of Verena.&lt;/h4&gt;

&lt;p&gt;Verena consists of the following parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The browser that runs the client-side program (including the app client and
the Verena client)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The server that runs the server-side program (including the app server and
the Verena server)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The app client and the app server are just normal web app clients and servers.
The Verena client and the Verena server speak the Verena protocol. There are places where the Verena mechanisms operate.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The identity provider (IDP) provides the public key for a given user (The
paper doesn&amp;rsquo;t really talk about it too much).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The hash server (HS) provides signed hashes, which can help the client verify
the proofs received from the server.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;thread-model-and-goal&#34;&gt;Thread model and goal&lt;/h4&gt;

&lt;p&gt;The server and HS, or the server and IDP cannot be both compromised.  Under
this assumption, Verena ensures that the client can notice if the data received
is not correct, fresh or complete (what they define as integrity).&lt;/p&gt;

&lt;h4 id=&#34;trust-contexts&#34;&gt;Trust Contexts&lt;/h4&gt;

&lt;p&gt;A trust context consists of a set of principals. Also, when it is associated
with a set of queries, it means that the results of the queries can only be
affected by the principals in the trust context.&lt;/p&gt;

&lt;h4 id=&#34;integrity-query-prototypes&#34;&gt;Integrity Query Prototypes&lt;/h4&gt;

&lt;p&gt;A Integrity Query Prototype (IQP), defined on a collection &lt;code&gt;C&lt;/code&gt;, consists of&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A trust context &lt;code&gt;TC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A read query pattern that decides a query set &lt;code&gt;Q_set&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given a query, Verena can determine which principals can affect its result by using IQPs.&lt;/p&gt;

&lt;h4 id=&#34;verena-protocols&#34;&gt;Verena protocols&lt;/h4&gt;

&lt;h5 id=&#34;reads&#34;&gt;Reads&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;The app client asks the Verena client to execute a query through a IQP&lt;/li&gt;
&lt;li&gt;The Verena client checks if it is the correct IQP. If it is, send the query
with a nonce (prevent replay attacks) to the server. Also, based on the IQP,
the Verena client knows the trust context of the query.&lt;/li&gt;
&lt;li&gt;The Verena server runs the query and also creates the proof for the result.
In addition, it figures out what hashes the Verena client needs to verify the
proof, then send hash requests, along with nonce from the client, to HS.&lt;/li&gt;
&lt;li&gt;The HS gets the requested hashes, and signs the hash requests, hashes, and
nonce into. It the sends this to the server.&lt;/li&gt;
&lt;li&gt;The Verena server then sends the result, the proof, and the signature from HS
to the Verena client.&lt;/li&gt;
&lt;li&gt;The Verena client verifies the proof to check the integrity of the result.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;writes&#34;&gt;Writes&lt;/h5&gt;

&lt;p&gt;The write protocol is similar to the read protocol, except it has one
additional step: The Verena client needs to help update the affected hashes of
the query. The Verena client, or more specifically the underlying principal
must be involved otherwise a compromised server can send HS fake hash updates.
The extra step happens after the second step in the read protocol&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The Verena server passes the related information to the Verena client,
including the entries (each entry consists of a hash, a version number and
the public key of the writer) on HS that are to be updated.
(Note the Verena server has all the information the HS has.)&lt;/li&gt;
&lt;li&gt;The Verena client calculates the new entries for HS, signs both new and old
entries, and passes the signature to the Verena server.&lt;/li&gt;
&lt;li&gt;The Verena server verifies the signature. If everything is OK, it updates its
copies of hashes (as mentioned before, the Verena server has all the
hashes HS has), and sends the signature to the HS to let HS update its hashes.&lt;/li&gt;
&lt;li&gt;The HS verifies the signature from the client and updates the entries.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that the Verena server sending its own copy of the old entries to the
client is only an optimization technique. Alternatively, the Verena server
could have just requested that from the HS, and the HS could have sent the
signed old entries. Obviously, this would be slow. Note, that because of this
optimization, a compromised server can send fake old entries to the client.
This is why the Verena client needs to additionally sign the old entries. On
the HS side: when the HS receives the signature from the client, it checks if
the signed old entries are the same as the ones it already has. If not, it will
reject the update since that would indicate that the server is has been
compromised.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hails</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/hails/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0704</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/hails/</guid>
      <description>

&lt;p&gt;Author: Matthew Chan&lt;/p&gt;

&lt;h3 id=&#34;what-is-the-main-contribution-of-the-paper&#34;&gt;What is the main contribution of the paper?&lt;/h3&gt;

&lt;p&gt;Aside from the artefact, the Model-&lt;em&gt;Policy&lt;/em&gt;-View-Controller architecture, which
provides a framework for building IFC enabled web applications.&lt;/p&gt;

&lt;h3 id=&#34;what-problem-does-mpvc-solve&#34;&gt;What problem does MPVC solve?&lt;/h3&gt;

&lt;p&gt;Traditional web application structure (i.e. MVC) has security checks littered
across the code base, mostly in the controllers &amp;ndash; the situation does not
improve across different kinds of frameworks, both client and server side View
frameworks suffer from the same problem (e.g. user metadata sanitization in the
view).  Specifying policy this way has two major disadvantages (a) policies have
to be specified multiple times for the same piece of data, leading to (b)
forgotten checks, inconsistent policies, and difficulties with revising the policies.&lt;/p&gt;

&lt;p&gt;MPVC allows for the centralised specification of security policies where they
logically belong (with the data) thus simplifying the view and controller by
making redundant checks in those components. This needs to be supported by a
runtime =&amp;gt; Hails.&lt;/p&gt;

&lt;h3 id=&#34;what-are-principals-what-are-the-three-types-of-principals-in-hails&#34;&gt;What are principals? What are the three types of principals in Hails?&lt;/h3&gt;

&lt;p&gt;A principal is a participant in the system who is allowed to read and write
data. Policies are specified in terms of principals. Unforgeable tokens called
&lt;em&gt;privileges&lt;/em&gt; represent the authority of principals at runtime.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Users&lt;/li&gt;
&lt;li&gt;VCs and remote resources they communicate with&lt;/li&gt;
&lt;li&gt;MPs&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;the-hails-dsl-allows-policies-to-be-specified-via-arbitrary-actions-does-this-affect-the-design-of-dclabels&#34;&gt;The Hails DSL allows policies to be specified via arbitrary actions. Does this affect the design of DCLabels?&lt;/h3&gt;

&lt;p&gt;It should not, since the labels evaluate to the same thing cf. policies
specified as pure functions, you still get a label in the DCLabels format. The
DSL affects only expressivity, and is safe with IFC controlled effects.&lt;/p&gt;

&lt;h3 id=&#34;how-is-the-hails-labelled-db-api-different-from-the-mp-dsl-does-one-get-the-same-guarantees-if-she-does-not-use-the-dsl&#34;&gt;How is the Hails labelled DB API different from the MP DSL? Does one get the same guarantees if she does not use the DSL?&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;MPs may contain arbitrary code and can expose an arbitrary API&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Hails DB API: wraps the underlying DB API with labels, part of the Hails TCB.&lt;/li&gt;
&lt;li&gt;MP DSL: for describing MPs, which translate to calls to the DB API.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The DB API can be used to express things that maybe the DSL cannot. This is
purely a matter of convenience; things are safe as long as the Hails libraries
are used (policy is mandated by the Hails runtime anyways).&lt;/p&gt;

&lt;h3 id=&#34;how-are-things-labelled-in-hails&#34;&gt;How are things labelled in Hails?&lt;/h3&gt;

&lt;p&gt;See Fig. 2 on pg. 7&lt;/p&gt;

&lt;p&gt;The Hails MP persistence model is based on a document-oriented model (similar to Mongo), where&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DB = { collection } (â‰ˆ tables)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Every database has a label&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;collection = { document } (â‰ˆ rows)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Every collection in a database has a collection label&lt;/p&gt;

&lt;p&gt;MPs can specify coarse-grained DB and coll labels.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;document = { field } (â‰ˆ K-V mappings).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fields can be indexed &lt;em&gt;keys&lt;/em&gt; identifying the document or non-indexed
  &lt;em&gt;elements&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Documents and Fields can be labelled via a function of type &lt;code&gt;Doc -&amp;gt; Label&lt;/code&gt;,
  i.e. label depends on document contents.&lt;/p&gt;

&lt;h3 id=&#34;why-does-hails-need-os-level-confinement-and-how-is-this-different-from-threads-are-there-alternative-designs-for-this-mechanism&#34;&gt;Why does Hails need OS level confinement and how is this different from threads? Are there alternative designs for this mechanism?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;For running external programs, i.e. &lt;code&gt;splint&lt;/code&gt; linter in the &lt;code&gt;gitstar&lt;/code&gt; example&lt;/li&gt;
&lt;li&gt;Threads =/= Processes; a process can have many threads. Spawning threads in
Hails/LIO is completely fine, the child thread acquires the label of its
parent.&lt;/li&gt;
&lt;li&gt;This confinement does not extend to spawned processes, so we need a kernel
level confinement solution. Hails uses standard Linux isolation mechanisms,
but other sandbox/container solutions might also work, i.e. Docker.&lt;/li&gt;
&lt;li&gt;As discussed in class, a possible design might be to &amp;ldquo;flip&amp;rdquo; the process model and
have all processes communicate via the safe Hails/LIO process. This way all IO
is labelled and spawned processes can have access to the network and other
resources. Sadly this doesn&amp;rsquo;t work because of label creep. (explain the
problem in detail?)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;how-is-hails-evaluated&#34;&gt;How is Hails evaluated?&lt;/h3&gt;

&lt;p&gt;Same as Shill:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Expressiveness/usability:&lt;/strong&gt; built a few applications with Hails, including one
by a team of undergraduate research interns who were novices in Haskell and
Hails. Found that MP was hard to get right but extension with VC is easy.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Performance:&lt;/strong&gt; Evaluation against existing mainstream web frameworks, mostly
demonstrating that interpreted languages (like Ruby) are terrible.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Performance is competitive cf. Java but&amp;hellip;&lt;/li&gt;
&lt;li&gt;DB performance is bad (mostly due to the Haskell Mongo library implementation,
according to Deian)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Security:&lt;/strong&gt; this is the focal point. Tiny TCB in application code across all
examples. How big is the TCB for the Hails library + runtime +
LIO/DCLabels/COWL ecosystem?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The other parts are formalized in Coq :+1:&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;another-policy-enforcing-framework-is-jeeves-jacqueline-how-is-hails-different&#34;&gt;Another policy enforcing framework is Jeeves/Jacqueline. How is Hails different?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Jeeves is a language, whereas Hails is a library/EDSL. This makes Hails more
flexible and easier to change from a language design point of view. (+ usual
host-language features for free argument for EDSLs)&lt;/li&gt;
&lt;li&gt;LIO&amp;rsquo;s programming model is more flexible (e.g., LIO has exceptions and threads).&lt;/li&gt;
&lt;li&gt;Jeeves is completely policy agnostic; Hails is &lt;em&gt;mostly&lt;/em&gt; policy agnostic. The
authors make a case for requiring policies be inspectable, i.e. to recover
from failures (see concurrent LIO).&lt;/li&gt;
&lt;li&gt;Jeeves can specify policies on concrete data stored in DB directly, Hails
requires a layer of indirection at the MP level. Unclear which is better.&lt;/li&gt;
&lt;li&gt;Hails has a story for confinement in the browser, via COWL, and for
enforcement at the OS level.&lt;/li&gt;
&lt;li&gt;LIO addresses covert channels and generally has a stronger attacker model.
Specifically, LIO supports termination sensitive noninterference (no leaks
via termination channel). Jeeves supports termination insensitive
noninterference (leaks via termination channel possible).&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Resin</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/resin/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0703</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/resin/</guid>
      <description>

&lt;p&gt;Author: Caroline Kim&lt;/p&gt;

&lt;h4 id=&#34;what-challenges-does-resin-aim-to-address&#34;&gt;What challenges does Resin aim to address?&lt;/h4&gt;

&lt;p&gt;Resin is a language runtime that equips programmers with the ability to encode and enforce data flow assertions. Resin provides data flow tracking while requiring few changes to the existing code.&lt;/p&gt;

&lt;h4 id=&#34;which-security-vulnerabilities-would-resin-catch-and-which-would-it-not&#34;&gt;Which security vulnerabilities would Resin catch and which would it not?&lt;/h4&gt;

&lt;p&gt;Main use case is protecting against web application vulnerabilities such as SQLi/XSS. It is assumed that both the entire language runtime and the application code itself is trustworthy &amp;ndash; Resin does not protect against bugs in this code.&lt;/p&gt;

&lt;p&gt;Resin does not catch implicit data flows such as those resulting from conditional branch and ordering of data.  Hence, the attacker model assumes that the application code itself is also trustworthy.&lt;/p&gt;

&lt;h4 id=&#34;how-does-resin-enforce-assertions&#34;&gt;How does Resin enforce assertions?&lt;/h4&gt;

&lt;p&gt;Through filter objects and policy objects. Policy objects are defined for data and filter objects are defined for channels. Assertions for data can be specified in policy objects through &lt;code&gt;export_check&lt;/code&gt; which will be called by filter objects.&lt;/p&gt;

&lt;p&gt;By having this separation, developers can revise policy objects without having to worry about all the filter objects.&lt;/p&gt;

&lt;h4 id=&#34;what-are-default-filter-objects&#34;&gt;What are default filter objects?&lt;/h4&gt;

&lt;p&gt;By default, Resin creates filter objects at the &amp;ldquo;edge of the runtime.&amp;rdquo; This encompasses all the runtime I/O, including sockets, HTTP layer, SQL layer, and other code imports. Less work for developers!&lt;/p&gt;

&lt;h4 id=&#34;how-does-resin-handle-data-tracking&#34;&gt;How does Resin handle data tracking?&lt;/h4&gt;

&lt;p&gt;Data objects are tagged with policy objects at the primitive-level (integer, character in a string, and files).&lt;/p&gt;

&lt;h4 id=&#34;how-do-several-assertions-co-exist-for-a-file&#34;&gt;How do several assertions co-exist for a file?&lt;/h4&gt;

&lt;p&gt;Multiple policy objects can be attached to a file as part of a policy set.  Policy objects are attached to data in a fine-grained manner via a merge. When a merge is needed Resin, by default, takes the union of policy objects. But this merge policy can be overridden.&lt;/p&gt;

&lt;h4 id=&#34;why-does-resin-serialize-policy-objects&#34;&gt;Why does Resin serialize policy objects?&lt;/h4&gt;

&lt;p&gt;For persistently stored data, Resin serializes policy objects so they don&amp;rsquo;t have to be saved manually.&lt;/p&gt;

&lt;p&gt;Importantly, only class names and field values are serialized; this allows policy object code to change without having to rewrite serialized policies.&lt;/p&gt;

&lt;h4 id=&#34;how-do-the-authors-evaluate-resin&#34;&gt;How do the authors evaluate Resin?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Security: Lines of code (how easy is it for developers), preventing vulnerability (100%?), whether it works properly on edge cases&lt;/li&gt;
&lt;li&gt;Performance: Overhead is 33%, overall. Higher when policy is present and a lot higher for those involving SQL operations (parsing the query is required)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>JIF</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/jif/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0702</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/jif/</guid>
      <description>

&lt;p&gt;Author: Sunjay Cauligi&lt;/p&gt;

&lt;h4 id=&#34;what-specific-guarantees-does-jif-give-what-don-t-they-give&#34;&gt;What specific guarantees does JIF give? What don&amp;rsquo;t they give?&lt;/h4&gt;

&lt;p&gt;No data leaks from within their framework, but no guarantees about certain
timing channels or other covert channels.&lt;/p&gt;

&lt;h4 id=&#34;how-does-jif-compare-to-conventional-ifc&#34;&gt;How does JIF compare to conventional IFC?&lt;/h4&gt;

&lt;p&gt;The main difference is the concept of multiple owners, each specifying their
own reader sets.&lt;/p&gt;

&lt;h4 id=&#34;slots-and-channels&#34;&gt;Slots and channels&lt;/h4&gt;

&lt;p&gt;Slots (variables) and channels cannot be relabeled; any data coming out of a
slot/channel takes on the label of that slot/channel.&lt;/p&gt;

&lt;p&gt;This means that data written to a variable is relabeled with that variable&amp;rsquo;s
label. (Why do it this way?)&lt;/p&gt;

&lt;h4 id=&#34;labels&#34;&gt;Labels&lt;/h4&gt;

&lt;p&gt;The effective reader set of any labeled data is the intersection of all reader
sets in that label.&lt;/p&gt;

&lt;p&gt;Declassification can only occur on a per-owner basis.&lt;/p&gt;

&lt;p&gt;Access-control checks are done on writes, and so aren&amp;rsquo;t necessary on reads.&lt;/p&gt;

&lt;h4 id=&#34;database-of-principal-hierarchies&#34;&gt;Database of principal hierarchies&lt;/h4&gt;

&lt;p&gt;If there is a centralized database, is this system truly decentralized?&lt;/p&gt;

&lt;p&gt;What challenges arise out of having this database?&lt;/p&gt;

&lt;p&gt;What happens if the database is modified while code is executing?&lt;/p&gt;

&lt;h4 id=&#34;why-does-jif-still-have-some-lightweight-dynamic-label-checking&#34;&gt;Why does JIF still have some lightweight dynamic label checking?&lt;/h4&gt;

&lt;p&gt;It needs dynamic label checking for more complex external sources of data, such
as filesystem or database access, to ensure its non-leakage property.&lt;/p&gt;

&lt;h4 id=&#34;how-does-jif-prevent-implicit-information-leakage&#34;&gt;How does JIF prevent implicit information leakage?&lt;/h4&gt;

&lt;p&gt;Blocks within if/while constructs are labeled according to their respective
branch conditions. Thus anything that happens inside one of these blocks is at
least as restricted as the knowledge of the branch condition.&lt;/p&gt;

&lt;h4 id=&#34;how-could-jif-be-improved-to-handle-timing-information-leaks&#34;&gt;How could JIF be improved to handle timing information leaks?&lt;/h4&gt;

&lt;p&gt;Open question.&lt;/p&gt;

&lt;h4 id=&#34;why-is-if-acts-for-necessary&#34;&gt;Why is &lt;code&gt;if_acts_for&lt;/code&gt; necessary?&lt;/h4&gt;

&lt;p&gt;JIF needs to check at run time whether the function has the correct authority
to act on the specified principal&amp;rsquo;s behalf.&lt;/p&gt;

&lt;h4 id=&#34;what-might-be-a-use-case-of-having-a-record-r-with-a-more-restrictive-label-than-a-field-r-f-in-r&#34;&gt;What might be a use case of having a record &lt;code&gt;r&lt;/code&gt; with a more restrictive label than a field &lt;code&gt;r.f&lt;/code&gt; in &lt;code&gt;r&lt;/code&gt;?&lt;/h4&gt;

&lt;p&gt;Incidentally, what is the label of &lt;code&gt;r.f&lt;/code&gt;? Is it &lt;u&gt;&lt;code&gt;f&lt;/code&gt;&lt;/u&gt;? &lt;u&gt;&lt;code&gt;r&lt;/code&gt;&lt;/u&gt; âŠ” &lt;u&gt;&lt;code&gt;f&lt;/code&gt;&lt;/u&gt;?&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-use-case-for-the-labelcase-construct&#34;&gt;What is the use case for the &lt;code&gt;labelcase&lt;/code&gt; construct?&lt;/h4&gt;

&lt;p&gt;When might one want to branch on a label&amp;rsquo;s runtime value?&lt;/p&gt;

&lt;h4 id=&#34;why-does-protected-t-exist-what-is-it-used-for&#34;&gt;Why does &lt;code&gt;protected[T]&lt;/code&gt; exist? What is it used for?&lt;/h4&gt;

&lt;p&gt;It&amp;rsquo;s used to implement the lightweight dynamic label checking mentioned above.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-use-case-for-the-get-label-function&#34;&gt;What is the use case for the &lt;code&gt;get_label&lt;/code&gt; function?&lt;/h4&gt;

&lt;p&gt;When might one want to examine the contained label inside a &lt;code&gt;protected[T]&lt;/code&gt;?&lt;/p&gt;

&lt;h4 id=&#34;why-does-get-expect-a-label-to-be-passed-in-what-prevents-one-from-simply-passing-in-the-label-returned-by-get-label&#34;&gt;Why does &lt;code&gt;get&lt;/code&gt; expect a label to be passed in? What prevents one from simply passing in the label returned by &lt;code&gt;get_label&lt;/code&gt;?&lt;/h4&gt;

&lt;p&gt;The label returned by &lt;code&gt;get_label&lt;/code&gt; is itself guarded with the label &lt;u&gt;&lt;code&gt;p&lt;/code&gt;&lt;/u&gt;,
which is the original guard on the original contained label. Since both the
&lt;code&gt;success&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; return values from &lt;code&gt;get&lt;/code&gt; are guarded by &lt;u&gt;&lt;code&gt;expect&lt;/code&gt;&lt;/u&gt;, only
someone with permissions for the original protected data can examine whether or
not they were able to successfully retrieve the value using &lt;code&gt;get&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;in-what-ways-is-a-protected-t-similar-to-a-capability-model&#34;&gt;In what ways is a &lt;code&gt;protected[T]&lt;/code&gt; similar to a capability model?&lt;/h4&gt;

&lt;p&gt;One can think of the &lt;code&gt;expect&lt;/code&gt; parameter as a capability for retrieving a value from a &lt;code&gt;protected[T]&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Shill</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/shill/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0701</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/shill/</guid>
      <description>

&lt;h4 id=&#34;what-is-the-problem-that-shill-is-trying-to-solve&#34;&gt;What is the problem that Shill is trying to solve?&lt;/h4&gt;

&lt;p&gt;Writing more secure shell scripts. Especially when some of these scripts may
not be trustworthy.&lt;/p&gt;

&lt;h4 id=&#34;shill-s-goal-is-to-follow-the-polp-what-is-this&#34;&gt;Shill&amp;rsquo;s goal is to follow the POLP. What is this?&lt;/h4&gt;

&lt;p&gt;Principle of least privilege: code should run only with the
privileges (authority) it needs to complete its task.&lt;/p&gt;

&lt;h4 id=&#34;what-is-their-driving-motivation-for-polp-what-are-their-security-requirements&#34;&gt;What is their driving motivation for POLP? What are their security requirements?&lt;/h4&gt;

&lt;p&gt;They wish to safely grade student assignments.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;can&amp;rsquo;t corrupt server&lt;/li&gt;
&lt;li&gt;can&amp;rsquo;t modify/leak test suite&lt;/li&gt;
&lt;li&gt;can&amp;rsquo;t copy solution from another submission&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;why-do-commodity-systems-and-their-secure-tools-not-support-the-polp&#34;&gt;Why do &amp;ldquo;commodity systems and their secure tools&amp;rdquo; not support the POLP?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;It&amp;rsquo;s difficult to even figure out what authority code needs. This is a
policy problem: it&amp;rsquo;s hard to specify policy today and it&amp;rsquo;s hard for others
to inspect the policy.&lt;/li&gt;
&lt;li&gt;Enforcement mechanisms are not good enough (too coarse grained, too
intrusive, not widely available).&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;how-does-shill-address-these-shortcomings&#34;&gt;How does Shill address these shortcomings?&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Capabilities and contracts address policy specification and policy auditing.&lt;/li&gt;
&lt;li&gt;Capabilities and contracts is used to enforce fine-grained policies at the
language-level. MAC is used to extend the enforcement to arbitrary
processes.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;in-addition-to-capabilities-shill-has-contracts-what-is-a-contract-why-does-shill-use-contracts&#34;&gt;In addition to capabilities, shill has contracts. What is a contract? Why does Shill use contracts?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Three kinds of contracts: function contracts, capability contracts, wallet contracts&lt;/li&gt;
&lt;li&gt;Shill uses them to impose restrictions on how code can use capabilities. This
is not only for security, but also for flexibility: You really want to make
it easy to compose code. This means not restricting your caller (be general
in what you accept and specific in what you produce): would be inflexible
programming model if code had to drop capabilities/privileges before calling
function.  Instead: can be privileged, but when you execute code the contract
restricts how capabilities are used. (Excuse the loose language.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;See Fig 5 contract.  This is what they&amp;rsquo;re referring to when talking about
  bounded parametric-polymorphism.&lt;/p&gt;

&lt;h4 id=&#34;how-does-shill-enforce-contracts-on-capabilities&#34;&gt;How does Shill enforce contracts on capabilities?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Proxies: wrappers around capabilities that check contract before use.&lt;/li&gt;
&lt;li&gt;This is interesting, because you can imagine a more complex contract that
allows for revocation.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;in-addition-to-enforcing-contracts-the-language-level-implementation-ensures-capability-safety-what-does-this-mean-how-does-this-affect-the-language-design&#34;&gt;In addition to enforcing contracts, the language-level implementation ensures capability-safety. What does this mean? How does this affect the language design?&lt;/h4&gt;

&lt;p&gt;Can only acquire caps:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;by introduction (from ambient script at script launch)&lt;/li&gt;
&lt;li&gt;as arguments (from user)&lt;/li&gt;
&lt;li&gt;deriving them from other capabilities&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Affects the language design:
- can&amp;rsquo;t serialize capabilities (why?)
- can&amp;rsquo;t have mutable variables (why?)&lt;/p&gt;

&lt;h4 id=&#34;what-are-ambient-shill-scrips-why-are-they-necessary&#34;&gt;What are ambient shill scrips? Why are they necessary?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Used to create initial set of caps to give to capability-safe scripts.&lt;/li&gt;
&lt;li&gt;Without these capabilities most scripts would not be able to do anything
useful. E.g., need to load libc.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-are-capability-wallets&#34;&gt;What are capability wallets?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;p6: &amp;ldquo;mechanism to automate and simplify the discovery, packaging, and
management of capabilities in a list&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Useful in writing real-world code that loads libraries and needs global
access to various parts of the filesystem, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;do-capability-wallets-reintroduce-some-of-the-ambient-authority-problem&#34;&gt;Do capability wallets reintroduce some of the ambient authority problem?&lt;/h4&gt;

&lt;p&gt;Unclear from paper. Seems like it would make it easy to load a non-trivial
number of caps, but then again it&amp;rsquo;s more declarative than today&amp;rsquo;s systems.
Seems like this is a functionality-security trade-off: abstracting away
capabilities is useful but may lead to cases where too many caps are left
around. Consider the case where libraries themselves change and may need
fewer privileges over time.&lt;/p&gt;

&lt;h4 id=&#34;how-does-shill-extend-its-security-to-arbitrary-processes&#34;&gt;How does Shill extend its security to arbitrary processes?&lt;/h4&gt;

&lt;p&gt;Creating sessions and associating process session. Each session has privilege
map that record the privs that the session has for various kernel objects.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MAC labels attached to kernel objects.&lt;/li&gt;
&lt;li&gt;MAC labels are used to enforce capability privileges.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Could this have influenced the language design? :)&lt;/p&gt;

&lt;h4 id=&#34;what-is-mac-why-does-shill-use-this-instead-of-extending-the-capability-model-to-the-os&#34;&gt;What is MAC? Why does Shill use this instead of extending the capability model to the OS?&lt;/h4&gt;

&lt;p&gt;Mandatory access control. Labels on objects are checked whenever object is
accessed. MAC doesn&amp;rsquo;t require changing code to use capability-style programming.&lt;/p&gt;

&lt;h4 id=&#34;do-shill-scripts-and-capability-sandboxed-processes-have-the-same-security-guarantees&#34;&gt;Do shill scripts and capability-sandboxed processes have the same security guarantees?&lt;/h4&gt;

&lt;p&gt;No. Sandboxed processes are vulnerable to confused deputy attacks: clients can
use paths.  Moreover &amp;ldquo;capability model&amp;rdquo; is different: MAC enforcement checks
permissions when accessing objects, so any permission will do &amp;ndash; don&amp;rsquo;t have to
use a capability.&lt;/p&gt;

&lt;h4 id=&#34;what-is-the-privilege-amplification-problem-how-do-they-address-this&#34;&gt;What is the privilege amplification problem? How do they address this?&lt;/h4&gt;

&lt;p&gt;Having two differently-privileged capabilities to the same object and using one
instead of the other.&lt;/p&gt;

&lt;p&gt;At the language level Shill doesn&amp;rsquo;t have to worry about this since capabilities
cannot be combined. They actually implement an &amp;ldquo;object capability&amp;rdquo; model.&lt;/p&gt;

&lt;p&gt;At the OS level: they simply don&amp;rsquo;t allow multiple capabilities to the same object.&lt;/p&gt;

&lt;h4 id=&#34;what-is-shill-s-threat-model-does-the-system-address-this&#34;&gt;What is Shill&amp;rsquo;s threat model? Does the system address this?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Shill scripts and shill executables are not trusted.&lt;/li&gt;
&lt;li&gt;Sometimes the contract may be untrustworthy.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;how-did-they-evaluate-shill&#34;&gt;How did they evaluate Shill?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Expressiveness: case studies (grading submission, package manager, apache, find &amp;amp; exec)&lt;/li&gt;
&lt;li&gt;Performance: some of the case studies, different implementation styles.&lt;/li&gt;
&lt;li&gt;Security: mostly coarse-grained vs. fine-grained. LOC for ambient scripts is interesting.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;is-it-expressive&#34;&gt;Is it expressive?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Seems like it. At least they looked at different case studies.&lt;/li&gt;
&lt;li&gt;Polymorphic contracts are a huge plus.&lt;/li&gt;
&lt;li&gt;How sandbox is used for apache is unclear. Mostly unclear how shill scripts fit in.&lt;/li&gt;
&lt;li&gt;How would you evaluate this more methodically?&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;where-is-most-of-the-overhead&#34;&gt;Where is most of the overhead?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Contract checking.&lt;/li&gt;
&lt;li&gt;Startup cost and creating sandboxes is also not cheap.&lt;/li&gt;
&lt;li&gt;How can these be optimized?&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;are-shill-scripts-more-secure-than-your-bash-scripts&#34;&gt;Are Shill scripts more secure than your bash scripts?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Definitely!&lt;/li&gt;
&lt;li&gt;The ambient scripts are not tiny. Would&amp;rsquo;ve been interesting to see if anybody
messed up writing these or contracts and how that may change the design.&lt;/li&gt;
&lt;li&gt;Can we evaluate the security more methodically?&lt;/li&gt;
&lt;li&gt;What kind of security does Shill buy you?&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;can-we-say-anything-about-the-implementation-of-the-runtime-itself&#34;&gt;Can we say anything about the implementation of the runtime itself?&lt;/h4&gt;

&lt;p&gt;Their implementation uses the &lt;code&gt;*at&lt;/code&gt; family system calls (you should too!) which
have a capability-like programming model. See
&lt;a href=&#34;http://static.usenix.org/legacy/events/sec10/tech/full_papers/Watson.pdf&#34;&gt;Capsicum&lt;/a&gt;
paper for more details.&lt;/p&gt;

&lt;h5 id=&#34;why-did-they-add-linkat-flinkat-etc-what-is-the-toctou-vulnerability&#34;&gt;Why did they add linkat, flinkat, etc.? What is the TOCTOU vulnerability?&lt;/h5&gt;

&lt;p&gt;Since their enforcement is not at the OS level they need the capability model
to ensure that the filesystem doesn&amp;rsquo;t change from under them.&lt;/p&gt;

&lt;p&gt;Suppose you want to open &lt;code&gt;/a/b/c&lt;/code&gt; for writing; the system would resolve
&lt;code&gt;/a/b/c&lt;/code&gt; and check if you have access to this. Let&amp;rsquo;s say OKAY. Before it gets
back to you, another process may have removed &lt;code&gt;c&lt;/code&gt; and created a link &lt;code&gt;c&lt;/code&gt; to
something you don&amp;rsquo;t have access to.&lt;/p&gt;

&lt;p&gt;See the &lt;a href=&#34;http://www.isoc.org/isoc/conferences/ndss/03/proceedings/papers/11.pdf&#34;&gt;Traps and
Pitffals&lt;/a&gt;
paper for more details.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Confused deputy</title>
      <link>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/confused-deputy/</link>
      <pubDate>Fri, 23 Sep 2016 01:37:21 -0700</pubDate>
      <author>deian&#43;cse291@cs.ucsd.edu (Deian Stefan)</author>
      <guid>https://cseweb.ucsd.edu/~dstefan/cse291-fall16/notes/confused-deputy/</guid>
      <description>

&lt;h4 id=&#34;what-is-the-scenario-that-the-paper-is-describing&#34;&gt;What is the scenario that the paper is describing?&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;(SYSX)FORT&lt;/code&gt; is a fortran compiler, that:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Needs to write stats to (SYSX)STAT&lt;/li&gt;
&lt;li&gt;Allows user to provide filename where debugging output is written to at run
time.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In order to do (1) the compiler is given the &lt;em&gt;home files license&lt;/em&gt;. This allows
the compiler to write files in its home directory.&lt;/p&gt;

&lt;h4 id=&#34;to-protect-files-the-system-was-using-access-control-lists-whare-are-acls&#34;&gt;To protect files the system was using access control lists. Whare are ACLs?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Lists associated with objects (files) that specify the subjects that are
allowed to access the objects (and how).&lt;/li&gt;
&lt;li&gt;Processes run on behalf of subjects. When accessing object system checks
if the object ACL permits the subject to access it.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-s-the-concrete-problem-they-ran-into&#34;&gt;What&amp;rsquo;s the concrete problem they ran into?&lt;/h4&gt;

&lt;p&gt;Billing info is stored in the home directory. So user can provide billing
filename to compiler and trash the directory with debugging info.&lt;/p&gt;

&lt;h4 id=&#34;what-s-the-underlying-problem&#34;&gt;What&amp;rsquo;s the underlying problem?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Authority to write to stats file was used to writte debugging output.&lt;/li&gt;
&lt;li&gt;If, instead, the ivoking user&amp;rsquo;s authority was used to write the debugging
output instead, there would be no problem.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is called the confused deputy problem. The fortran compiler was confused
into using the authority for one purpose towards another goal.&lt;/p&gt;

&lt;h4 id=&#34;can-t-we-just-set-the-right-acls&#34;&gt;Can&amp;rsquo;t we just set the right ACLs?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;No, this get super complicated. It sometimes breaks secure programs (too
restricting). Other times it&amp;rsquo;s insecure (not restricting enough).&lt;/li&gt;
&lt;li&gt;They had to write requirements as long boolean formulae.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;what-is-the-switching-hat-idea-why-didn-t-it-work&#34;&gt;What is the switching hat idea? Why didn&amp;rsquo;t it work?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Syscall that allowed switching mode from one authority to another.&lt;/li&gt;
&lt;li&gt;Didn&amp;rsquo;t generalize beyond file system or two authorities.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Is this fundamental or mode a limitation of their exploration? Can you think of
a way of making the &amp;ldquo;swtching hats&amp;rdquo; idea work if you can modify the programming
language and have more than 1 single syscall change at your disposal.&lt;/p&gt;

&lt;h4 id=&#34;what-are-capabilities-and-how-do-they-solve-this-problem&#34;&gt;What are capabilities and how do they solve this problem?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A capability tells you which file to access and gives you the authority to do
so. It removes the disconnect between naming and authority.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;With capabilities:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The system gives the compiler the capability to the stats file.&lt;/li&gt;
&lt;li&gt;When invoking the compiler, the user must give the compiler the capabililty
to the debugging file. If the user has this capablity, we know that they
can write to the file. So the compiler can write to it too. Importantly, it
cannot be confused into writing to the billing file since it doesn&amp;rsquo;t have
the capablity (name+authority) to this file. Something must grant it this
capability.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;capabilities-can-help-the-with-trojan-horses-problem-what-is-this-and-how-do-capabilties-help&#34;&gt;Capabilities can help the with &lt;em&gt;Trojan horses&lt;/em&gt; problem; what is this? And how do capabilties help?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Call program to do one thing and it does something else.&lt;/li&gt;
&lt;li&gt;Capabilities help by limiting what the program can do. Only give program
least authority it needs. Consequence: &amp;ldquo;principle of least surprise&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;capabilities-can-help-the-with-the-mutually-suspicious-users-problem-what-is-this-and-how-do-capabilities-help&#34;&gt;Capabilities can help the with the &lt;em&gt;mutually suspicious users problem&lt;/em&gt;; what is this? And how do capabilities help?&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Common scenario: Alice has sensitive data (taxes) and wisher to run Bob&amp;rsquo;s
accounting program. Bob doesn&amp;rsquo;t want to share his super secret algorithm.&lt;/li&gt;
&lt;li&gt;Can run program with no capabilities other than the ones you grant it. This
ensures that if you don&amp;rsquo;t give it capability to talk to network, it can&amp;rsquo;t do
so.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;rsquo;ll see how information flow control helps address this problem and what the
different trade offs are.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>